\section{Teoria della calcolabilità}

\subsection{Sistema di calcolo \texorpdfstring{$\SC$}{C}}
Si vuole modellare matematicamente un calcolatore o sistema di calcolo $\SC$:
\vspace{.4cm}
\begin{figure}[h]
    \centering
    \input{figures/sistema_calcolo.tex}
\end{figure}

La figura mostra il sistema di calcolo $\SC$ che, preso un programma $P$
su input $x$, restituisce in output il risultato $y$ o il valore $\perp$
se il programma va in loop.

DATI è l'insieme di tutti i possibili dati di input e PROG l'insieme di
tutti i possibili programmi.

Il sistema di calcolo $\SC$ non fa altro che eseguire il programma $P$ su input
$x$ ricavandone il risultato $y$:
\begin{equation}\label{eq:sistema_calcolo}
\SC:\text{PROG}\times\text{DATI}\rightarrow\text{DATI}_\perp
\end{equation}

Quello che fa il programma $P$ è trasformare il dato di input $x$ in un dato
di output $y$; si può quindi dire che un programma non è altro che
una funzione che agisce da DATI in DATI:
$$ P:\text{DATI} \rightarrow \text{DATI}_\perp $$
$$ \Downarrow $$
\begin{equation}\label{eq:prog_dati} \text{PROG} =
\text{DATI}^{\text{DATI}}_\perp \end{equation}

La funzione associata al programma $P$ è detta \textbf{semantica di $P$}.

Da (\ref{eq:sistema_calcolo}) e (\ref{eq:prog_dati}) si ottiene che:
$$ \SC:\text{DATI}^{\text{DATI}}_\perp\times\text{DATI}
\rightarrow\text{DATI}_\perp $$

$\SC$ è una funzione di valutazione; $\SC(P,x)$ è infatti la semantica di $P$.

\subsection{Potenza computazionale di \texorpdfstring{$\SC$}{C}
\label{sec:pot_comp}}
Si definisce potenza computazionale di $\SC$:
$$ F(\SC) = \{\SC(P,\_):P\in\text{PROG}\} \subseteq \text{DATI}^{\text{DATI}}_\perp $$
\textbf{$F(\SC)$ contiene tutto ciò che un qualsiasi sistema di calcolo $\SC$
può calcolare}. Quindi, per stabilire cosa l'informatica può risolvere, basta stabilire
il carattere dell'inclusione:
\begin{itemize}
    \item $F(\SC)\subset\text{DATI}^{\text{DATI}}_\perp \Rightarrow $
        esistono problemi che l'informatica non può risolvere;
    \item $F(\SC)=\text{DATI}^{\text{DATI}}_\perp \Rightarrow $
        l'informatica può risolvere tutto.
\end{itemize}

\subsection{Cardinalità di insiemi infiniti}
Per riuscire a capire se l'inclusione
$F(\SC)\subseteq\text{DATI}^{\text{DATI}}_\perp$ sia propria o meno, si confronterà
la cardinalità dei due insiemi. Infatti dalla cardinalità si può ricavare che:
\begin{itemize}
    \item Se $|F(\SC)|<\left|\text{DATI}^{\text{DATI}}_\perp\right|
    \quad \Rightarrow \quad F(\SC)\subset\text{DATI}^{\text{DATI}}_\perp$;
    \item Se $|F(\SC)|=\left|\text{DATI}^{\text{DATI}}_\perp\right|
    \quad \Rightarrow \quad F(\SC)=\text{DATI}^{\text{DATI}}_\perp$.
\end{itemize}

Il concetto di cardinalità è semplice quando si tratta di insiemi finiti: basta
contare il numero di elementi che compongono l'insieme. Tuttavia, in presenza
di insiemi infiniti le cose si complicano.

Per esempio, si confrontino $\N$ e $\RN$: entrambi hanno cardinalità infinita
($|\N|=|\RN|=\infty$) eppure $\N\subset\RN$! Per comprendere quindi meglio
la cardinalità di insiemi infiniti si dovrà andare più nel dettaglio.

\subsubsection{Relazione binaria}
Si definisce relazione binaria $R$ sull'insieme $A$, un elenco di coppie ordinate
di elementi di $A$: $R\subseteq A^2$. Due elementi $a,b\in A$ sono in relazione 
$R$ se $(a,b)\in R$. Si usa la notazione:
\begin{itemize}
    \item $a \ R \ b$: $a$ è in relazione $R$ con $b$;
    \item $a\ \cancel{R} \ b$: $a$ non è in relazione $R$ con $b$;
\end{itemize}

\subsubsection{Relazione di equivalenza}
$R\subseteq A^2$ è una relazione di equivalenza se gode di:
\begin{enumerate}
    \item Riflessività: $\forall a \in A \quad a \ R \ a$
    \item Simmetria: $\forall a,b \in A \quad a \ R \ b \ \Leftrightarrow \ b \ R \ a$
    \item Transitività: $\forall a,b,c \in A \quad a \ R \ b
    \ \wedge \ b \ R \ c \Rightarrow a \ R \ c $
\end{enumerate}

\subsubsection{Classe di equivalenza}
Si definisce classe di equivalenza $[a]_R$ l'insieme degli elementi in relazione $R$
con $a$:
$$ [a]_R =\{b\in A: a \ R \ b\} $$

Tutte le classi di equivalenza di $R$ formano una partizione di $A$. L'insieme $A$
partizionato attraverso le classi di equivalenza di $R$ è detto \textbf{quoziente}
di $A$ rispetto a $R$ ed è denotato da $\sfrac{A}{R}$.

\subsubsection*{Esempio}
Si consideri la relazione $\equiv_4\subseteq\N^2$ di equivalenza modulo 4. Due numeri
sono in relazione di equivalenza modulo 4 se il resto della divisione per 4 è uguale
per entrambi.
$$ 5\equiv_4 9\ , \ 10\equiv_4 2 \ , \ \dots $$

Le classi di equivalenza sono:
\begin{align}
    [0]_4&=\{4k\}\tag{Multipli di 4}\\
    [1]_4&=\{4k+1\}\tag{Resto 1}\\
    [2]_4&=\{4k+2\}\tag{Resto 2}\\
    [3]_4&=\{4k+3\}\tag{Resto 3}
\end{align}
L'insieme $\{[0]_4,[1]_4,[2]_4,[3]_4\}=\sfrac{\N}{\equiv_4}$ è una partizione di $\N$.

\subsubsection{Insiemi isomorfi}
Due insiemi $A$ e $B$ sono \textbf{isomorfi} (o equinumerosi) se esiste una funzione
biettiva tra essi. Formalmente si indica con:
$$ A\sim B $$
La relazione di isomorfismo $\sim$ è una relazione di equivalenza in quanto:
\begin{enumerate}
    \item Riflessiva: si usi la funzione identità;
    \item Simmetrica: se esiste una funzione biettiva allora anche la sua inversa
        è biettiva;
    \item Transitiva: la composizione di due funzioni biettive è una funzione biettiva.
\end{enumerate}

Sia $\mathscr{U}$ l'insieme universo, ovvero l'insieme che contiene tutti gli insiemi.
Il quoziente di $\mathscr{U}$ rispetto a $\sim$ ($\sfrac{\mathscr{U}}{\sim}$) definisce il 
concetto di cardinalità:

\begin{figure}[H]
    \centering
    \input{figures/cardinalita.tex}
\end{figure}

Ogni partizione di $\sfrac{\mathscr{U}}{\sim}$ contiene gli insiemi tra loro isomorfi, ovvero
che hanno la stessa cardinalità.

\subsubsection*{Insiemi finiti}
Si definisca la famiglia di insiemi: 
$$J_n=\begin{cases}
\cancel{O} & n=0\\
\{1,\dots ,n\} & n>0
\end{cases}$$
$$ J_0=\{\}\ , \ J_1=\{1\} \ , \ J_{2}=\{1,2\} \ , \ J_{3}=\{1,2,3\}\ , \ \dots $$

Un'insieme $A$ ha cardinalità finita se $\exists n\in\N : A\sim J_n$ e si può dire che
$|A|=n$.

\subsubsection*{Insiemi infiniti}
Un insieme che non è finito ha cardinalità infinita.

\subsubsection{Insiemi numerabili}
Un insieme $A$ è numerabile se $\N\sim A$ (ovvero $A\in [\N]_\sim$). Vuole quindi dire
che esiste una biezione $f:\N\rightarrow A$ che permette di listare $A$ come:
$$ A = \{f(0),f(1),f(2),\dots\} $$
senza tralasciare nessun elemento.
\subsubsection*{Esempi}
\begin{tabular}{r l}
    PARI :& $f(n)=2n$ \\
    DISPARI :& $f(n)=2n+1$ \\
    $\mathbb{Z}$ :& mappo i pari nei non-negativi e i dispari nei negativi \\
    $\{0\}\cup 1\{0,1\}^*$ :& converto da binario a decimale \\
\end{tabular}

\subsubsection{Insiemi non numerabili}
Gli insiemi non numerabili sono insiemi a cardinalità infinita ma non listabili come
$\N$ (sono \quotes{più fitti}). Il re di questi insiemi è $\RN$.

\begin{theorem}
    $\RN$ è un insieme non numerabile: $$ \N \nsim \RN $$
\end{theorem}
\begin{proof} Per dimostrarlo dimostro che:
    \begin{enumerate}
        \item $\RN \sim (0,1)$: la biezione è rappresentata graficamente in figura:
            \vspace{-.2cm}
            \begin{figure}[H]
                \centering
                \input{figures/reali_zero_uno.tex}
            \end{figure}\vspace{-.6cm}
            (In realtà $\RN$ è isomorfo a un suo qualsiasi intervallo).
        \item $\N \nsim (0,1)$: dimostrazione per assurdo: assumo che $\N \sim (0,1)$;
            Questo vorrebbe dire che tutti i numeri compresi tra 0 e 1 sono numerabili.
            Elenco tutti i numeri associandoli a un numero naturale:

            \begin{minipage}{.45\textwidth}
                $$0\ \mapsto \ 0.{\color{red}a_{00}}\ a_{01}\ a_{02}\ a_{03}\ a_{04}\ \dots$$
                $$1\ \mapsto \ 0.a_{10}\ {\color{red}a_{11}}\ a_{12}\ a_{13}\ a_{14}\ \dots$$
                $$2\ \mapsto \ 0.a_{20}\ a_{21}\ {\color{red}a_{22}}\ a_{23}\ a_{24}\ \dots$$
                $$3\ \mapsto \ 0.a_{30}\ a_{31}\ a_{32}\ {\color{red}a_{33}}\ a_{34}\ \dots$$
                $$4\ \mapsto \ 0.a_{40}\ a_{41}\ a_{42}\ a_{43}\ {\color{red}a_{44}}\ \dots$$
                $$\vdots\qquad\vdots\qquad\vdots\qquad\vdots\qquad\vdots\qquad\ddots$$
                \vspace{.4cm}
            \end{minipage}
            \begin{minipage}{.48\textwidth}
                $a_{ij}$ è la $i$-esima cifra dopo lo zero del $j$-esimo numero
                nella lista.

                Se $(0,1)$ fosse numerabile tutti i suoi numeri dovrebbero far parte
                della lista.

                Si consideri il numero:
                $$ 0.c_0c_1c_2c_3\dots $$

                con: $$ c_i = \begin{cases}
                2 & a_{ii}\neq2\\
                3 & a_{ii}=2
                \end{cases} $$

            \end{minipage}
            Chiaramente $0.c_0c_1c_2c_3\dots\in(0,1)$ ma non appare nella lista:
            \begin{itemize}
                \item Differisce dal primo numero perchè $c_0\neq a_{00}$;
                \item Differisce dal secondo numero perchè $c_1\neq a_{11}$;
                \item $\dots$
                \item Differisce da qualunque numero nella lista sulla cifra 
                    {\color{red} diagonale}.
            \end{itemize}
            Ho trovato l'assurdo quindi $\N \nsim (0,1)$ (dimostrazione per 
            diagonalizzazione).
    \end{enumerate}
    Sfruttando la transitività di $\sim$ posso si può affermare quindi che:
    $$ \RN \underset{(1)}{\sim} (0,1) \underset{(2)}{\nsim} \N \quad \Rightarrow \quad \RN \nsim \N $$
\end{proof}

Tutti gli insiemi isomorfi a $\RN$ sono detti continui. Altri insiemi non numerabili sono:
\begin{itemize}
    \item $2^\N\nsim\N$: insieme delle parti di $\N$ ovvero $2^\N = \{\text{sottoinsiemi di } \N\}$
    \item $\N^\N_\perp\nsim\N$: insieme delle funzioni da $\N$ a $\N$ ovvero
        $\N^\N_\perp = \{f:\N\rightarrow\N_\perp\}$
\end{itemize}

\subsection{Esistono funzioni non calcolabili?}
Ora che il concetto di cardinalità è più chiaro, si riprenda il concetto di 
potenza computazionale di un sistema di calcolo $\SC$ (paragrafo \ref{sec:pot_comp}):
$$
F(\SC) = \{\SC(P,\_):P\in\text{PROG}\} \subseteq \text{DATI}^{\text{DATI}}_\perp
$$

Per definizione $F(\SC)$ ha la stessa numerosità di PROG:
$$ F(\SC) \sim \text{PROG} $$

Ragionevolmente, \textbf{ma non formalmente}, si può notare che:
\begin{itemize}
    \item PROG\ $\sim\N$: si prenda la stringa binaria con la quale il programma è
        salvato sul disco e si converta da binario a decimale;
    \item DATI\ $\sim\N$: si applichi lo stesso ragionamento del punto precedente.
\end{itemize}
Ne segue che:
$$ F(\SC) \sim \text{PROG} \sim \N \nsim\N^\N_\perp\sim \text{DATI}^\text{DATI}_\perp$$
$$ \Downarrow $$
$$ F(\SC) \nsim \text{DATI}^\text{DATI}_\perp $$
$$ \Downarrow $$
$$ F(\SC) \subset \text{DATI}^\text{DATI}_\perp $$

Quello che questa osservazione dice è che ho pochi programmi ($\N$) e troppe
funzioni ($\N^\N_\perp$).
\textbf{Alla domanda \quotes{Esistono funzioni non calcolabili?} si può quindi 
rispondere con un sì!}

\subsection{\texorpdfstring{DATI\ $\bm{\sim\N}$}{DATI~N}}
Obiettivo di questa sezione è dimostrare formalmente che:
$$ \text{DATI} \sim \N $$
Vogliamo quindi trovare una biezione che è in grado di associare biunivocamente
dei dati a un numero e quindi anche di ottenere i dati di partenza dal
numero. Per farlo si userà il seguente teorema.

\begin{theorem}
    $\N\times\N\sim\N^+$
\end{theorem}
\begin{proof}
    Si definisca la funzione coppia di Cantor $\cantor{\ ,\ }$:
    $$ \cantor{\ ,\ }:\N\times\N\rightarrow\N^+ $$
    $\cantor{\ ,\ }$ associa biunivocamente una coppia di numeri $x$ e 
    $y$ a un numero $n$:
    $$ \cantor{x,y} = n $$
    La mappa che $\cantor{\ ,\ }$ usa per assegnare i valori di ogni coppia viene 
    descritta nelle seguenti tabelle:

    \begin{minipage}{.48\textwidth}
        \centering
        \begin{tabular}{c|c c c c c c}
            $x\backslash y$&0 &1 &2 &3 &4\\ \hline
               0 &1 &3 &6 &10&15\\
               1 &2 &5 &9 &14&...\\
               2 &4 &8 &13&...&  \\
               3 &7 &12&...&  &  \\
               4 &11&...&  &  &  \\
               5 &$\nearrow$&&&&\\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.48\textwidth}
        \centering
        \input{figures/tabella_cantor.tex}
    \end{minipage}

    Si vuole calcolare ora la forma analitica di $\cantor{\ ,\ }$; si prenda una generica
    coppia di numeri $\cantor{x,y}$:

    \begin{minipage}{.4\textwidth}
        \centering
        \input{figures/cantor_analitica.tex}
    \end{minipage}
    \begin{minipage}{.58\textwidth}
        Per come è definita $\cantor{x,y}$ (vedi tabella precedente) si ha che:
        \begin{equation}\label{eq:cantor_analytic}
            \cantor{x,y} = {\color{blue}\cantor{x+y,0}}{\color{red}+y}
        \end{equation}

        Ora l'incognita da calcolare resta $\color{blue}\cantor{z,0}$ che,
        si può ottenere come:
        \begin{equation}\label{eq:cantor_analytic_2}
            \cantor{z,0} = \sum_{i=0}^z i+1 = \frac{z(z+1)}{2}+1
        \end{equation}
    \end{minipage}
    
    Da (\ref{eq:cantor_analytic}) e (\ref{eq:cantor_analytic_2}) segue che:
    $$ \cantor{x,y} = \cantor{x+y,0}+y = \frac{(x+y)(x+y+1)}{2}+y+1 $$
    
    $\cantor{\ ,\ }$ si dimostra quindi mappare univocamente le coppie di numeri
    in numeri ($\N^2\rightarrow\N^+$). Si cercherà ora di mostrare il passaggio inverso, 
    ovvero come riottenere la coppia di numeri dal numero risultante
    ($\N^+\rightarrow\N^2$).

    Si definiscano le seguenti funzioni:
    $$ \cantor{x,y} = n \quad , \quad \sx(n) = x \quad , \quad \dx(n) = y $$

    Da (\ref{eq:cantor_analytic}) si ha che:
    $$ \begin{aligned}
        y &= \cantor{x,y}-\cantor{x+y,0} \\
          &= n-\cantor{x+y,0} \\
          &= n-\cantor{\gamma,0} \\
    \end{aligned} $$
    Il valore di $\gamma$ è il più grande valore che, messo sulla prima colonna
    ($\cantor{\gamma,0}$), non supera $n$:
    $$ \gamma = \max\{z\in\N:\cantor{z,0}\leq n\} $$
    $$ \cantor{z,0}\leq n $$
    $$ \frac{z(z+1)}{2}+1 \leq n $$
    $$ z^2+z+2-2n\leq 0 $$
    $$ \frac{-1-\sqrt{8n-7}}{2}\leq z \leq \frac{-1+\sqrt{8n-7}}{2} $$
    $$ \Downarrow $$
    $$ \gamma=\left\lfloor\frac{-1+\sqrt{8n-7}}{2}\right\rfloor $$
    
    In conclusione:
    $$ \dx(x) = n-\cantor{\gamma,0} $$
    \begin{equation} \sx(x) = \gamma-des(x) \tag{non è il seno} \end{equation}

    La funzione coppia di Cantor $\cantor{\ ,\ }$ si è quindi mostrata
    essere una biezione tra $\N^+$ e $\N^2$, mostrando che i due insiemi
    hanno la stessa cardinalità.
\end{proof}

È facile poi, partendo da $\cantor{\ ,\ }$, creare una biezione tra $\N$ e $\N^2$
(dimostrando che $\N\times\N\sim\N$):
$$ [\ ,\ ]:\N\times\N\rightarrow\N $$
$$ [x,y] = \cantor{x,y}-1 $$

Il precedente risultato mette alla luce anche che:
$$ \mathbb{Q}\sim\N $$
in quanto ogni suo elemento non è altro che una coppia di numeri messi
a frazione.

Ora che si ha appurato l'esistenza di una biezione tra coppie di numeri e numeri si può
facilmente estendere questa relazione a liste d'interi, dove con lista si intende una
sequenza di numeri di lunghezza non nota:
$$ x_1,x_2,\dots,x_m \rightarrow \cantor{x_1,x_2,\dots,x_m} $$
Per farlo basterà applicare $\cantor{\ ,\ }$ come segue:
$$ \cantor{x_1,x_2,\dots,x_m} = 
\cantor{x_1,\cantor{x_2,\cantor{\dots,\cantor{x_m,0}\dots}}} $$
Dove lo 0 a destra della coppia di Cantor più interna rappresenta il fine lista.

La decodifica invece avverrà nel seguente modo:
\begin{figure}[H]
    \centering
    \input{figures/cantor_list_dec.tex}
\end{figure}

Se si conosce il numero di elementi della sequenza di numeri, non si usa una lista ma un
\textbf{array}:
$$ [x_1,\dots,x_n] = [x_1,[x_2,[\dots,[x_{n-1},x_n]]\dots]] $$
Conoscendo già la lunghezza non c'è bisogno dello 0 di fine lista.

Qualsiasi tipo di dato può essere convertito a una lista di numeri:
\begin{itemize}
    \item Testi: non sono altro che liste di caratteri i quali possono essere convertiti
        in numeri tramite tabella ASCII;
    \item Suoni: si usa un campionamento a una data frequenza ottenendo una lista di
        valori;
    \item Matrici: una matrice è una lista di liste;
    \item Immagini: ogni pixel contiene la codifica numerica di un colore; in questo modo
    un'immagine non è altro che una matrice di numeri grande quanto la sua risoluzione;
    \item Grafi: uso liste o matrici di adiacenza.
\end{itemize}

\textbf{Si può quindi affermare che $\bm{\text{DATI}\sim\N}$}.

\subsection{\texorpdfstring{PROG\ $\bm{\sim\N}$}{PROG~N}}
Obiettivo di questa sezione è dimostrare formalmente che:
$$ \text{PROG} \sim \N $$
Per poterlo fare si dovrà definire formalmente un sistema di calcolo specifico: il sistema 
di calcolo RAM, composto dalla macchina RAM e il linguaggio RAM. Quest'ultimo si può 
riassumere come un assembly molto semplificato.

L'idea è di usare il sistema RAM come rappresentativo di tutti i possibili sistemi di calcolo;
ne segue che $F(\RAM)$, ovvero la potenza computazionale di un sistema RAM, permetterà
di capire cosa i sistemi di calcolo sono in grado di calcolare.

Può però sorgere spontaneo un dubbio: il sistema RAM non è troppo semplice per rappresentare
tutti i sistemi di calcolo? Se il sistema RAM non fosse in grado di risolvere
certi problemi, magari altri sistemi più complessi lo sarebbero.

Per verificare questo caso si vedrà successivamente un altro sistema di calcolo più
sofisticato: quello WHILE. Il confronto tra le due potenze computazionali porterebbe a:
\begin{itemize}
    \item $F(\WHILE)\neq F(RAM) \Rightarrow$ la computabilità dipende dallo strumento usato;
    \item $F(\WHILE)=F(RAM) \Rightarrow$ la computabilità è intrinseca nei problemi 
        (tesi di Church-Turing).
\end{itemize}

\subsubsection{Sistema di calcolo RAM}
\subsubsection*{Macchina RAM}
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram.tex}
\end{figure}
\begin{itemize}
    \item $L$ contiene l'indirizzo della prossima istruzione da eseguire ($1\leq L\leq |P|$)
    \item $P$ è il programma ovvero una lista di istruzioni $\text{Istr}_i$
    \item $R_i$ è un generico registro di memoria che può contenere un numero naturale:
    \begin{itemize}
        \item $R_0$ è il registro specifico dove verrà deposto l'output del programma
        \item $R_1$ è il registro specifico dove verrà letto l'input del programma
        \item Il numero dei registri è illimitato
    \end{itemize}
\end{itemize}
\subsubsection*{Linguaggio RAM}
La sintassi del linguaggio RAM è molto intuitiva; ci sono tre tipi di istruzioni:

\begin{minipage}{.4\textwidth}
    \begin{enumerate}
        \itemsep.5em 
        \item $R_k \leftarrow R_k +1$ 
        \item $R_k \leftarrow R_k \dotminus 1$
        \item $\goto{R_k}{m}$
    \end{enumerate}
\end{minipage}
\begin{minipage}{.49\textwidth}
    $$x\dotminus y =\begin{cases}x-y&x\geq y\\ 0 &\text{altrimenti}\end{cases}$$
\end{minipage}

Si noti che il numero di istruzione $m$ usato nel terzo comando deve essere compreso tra
1 e $|P|$ inclusi.

\subsubsection*{Esecuzione}
Per eseguire un programma $P$ su input $\color{red}n$ la macchina verrà inizializzata come segue:
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram_init.tex}
\end{figure}

Successivamente si eseguirà un'istruzione dopo l'altra, a partire dalla prima, facendo quindi
incrementare di uno il program counter ($L\leftarrow L+1$) dopo l'esecuzione di ogni istruzione.
Se l'istruzione è un'istruzione di salto ($\goto{R_k}{m}$) e la sua condizione $R_k=0$
è verificata, il program counter verrà cambiato in $L\leftarrow m$.

Per convenzione $L=0 \Rightarrow \text{ Fine del programma}$ (con possibilità di loop infinito).

L'output del programma sarà il contenuto di $R_0$ o $\perp$ in presenza di loop.

\subsubsection*{Semantica operazionale}
La semantica operazionale descrive formalmente il significato di ogni istruzione; per farlo
specifica l'effetto che l'istruzione ha sui registri della macchina.

L'esecuzione di un programma è una sequenza di stati della macchina, dove uno stato descrive
precisamente l'attuale situazione della macchina. Ogni istruzione fa passare la macchina da
uno stato ad un altro:
$$ \text{STATO}_1 \rightarrow \boxed{\text{Istr}_i} \rightarrow \text{STATO}_2 $$
$$ (\text{STATO}_1,\text{STATO}_2) = \text{semantica operazionale di Istr}_i $$

Ampliando il concetto di semantica dalla singola istruzione all'intero programma si ha che 
quest'ultimo induce una sequenza di stati:
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram_stati.tex}
\end{figure}

La semantica di $P$ è:
$$ \semRAM_P:\N\to\N_\perp $$
$$ \semRAM_P(n) = \begin{cases}
\perp & \text{se $P$ va in loop}\\
y & \text{altrimenti}
\end{cases} $$

\subsubsection*{Stato}
Come già anticipato, uno stato è una \quotes{foto} di tutte le componenti della macchina
in un dato istante. Formalmente si definisca uno stato come una funzione:
$$ \Stato:\{L,R_i\}\to\N $$
$$ \Stato(R_j) = \text{contenuto del registro $R_j$ quando la macchina è nello stato 
$\Stato$}$$

I possibili stati della macchina sono:
$$ \text{STATI} = \N^{\{L,R_i\}} $$

Uno stato è finale se $\Stato(L)=0$.

La funzione di inizializzazione $in$, preso l'input del programma, restituisce lo stato
iniziale:
$$ in:\text{DATI}\to\text{STATI} $$
$$ in(n) = \Stato_{init} $$
$$ \Stato_{init}(L) = 1 \qquad\qquad \Stato_{init}(R_i) = \begin{cases}
n & i=1\\
0 & i\neq 1
\end{cases} $$

\subsubsection*{Funzione stato prossimo}
A definire la dinamica del programma è la funzione stato prossimo $\delta$:
$$ \delta : \text{STATI}\times\text{PROG}\to\text{STATI}_\perp $$
$$ \delta({\color{red}\Stato},P) = {\color{blue}\Stato'} $$
$$ {\color{red}\text{Stato attuale}} \qquad {\color{blue}\text{Stato prossimo}} $$

\begin{enumerate}
    \item Se $\Stato(L)=0$ allora $\Stato'=\perp$
    \item Se $\Stato(L)>|P|$ allora $\Stato'(L)=0$ e $\forall i:\Stato'(R_i)=\Stato(R_i)$
    \item Se $1\leq\Stato(L)\leq |P|$: considera la $\Stato(L)$-esima istruzione:
        \begin{enumerate}
            \item Se $R_k \leftarrow R_k +/\dotminus 1$ allora:
                \begin{itemize}
                    \item $\Stato'(R_k) = \Stato(R_k)+/\dotminus 1$
                    \item $\Stato'(L) = \Stato(L)+1$
                    \item $\forall i:i\neq k \quad \Stato'(R_i) = \Stato(R_i)$
                \end{itemize}
            \item Se $\goto{R_k}{m}$ allora:
                \begin{itemize}
                    \item Se $\Stato(R_k)=0$ allora $\Stato'(L) = m$
                    \item Altrimenti $\Stato'(L) = \Stato(L)+1$
                \end{itemize}
        \end{enumerate}
\end{enumerate}

\subsubsection*{Esempio di programma}
\vspace{-1em}
\begin{minipage}{.48\textwidth}
    \begin{align}
        P \equiv\ & \goto{R_1}{6}       \notag\\
        & R_0 \leftarrow R_0+1          \notag\\
        & R_0 \leftarrow R_0+1          \notag\\[-.3em]
        & R_1 \leftarrow R_1\dotminus 1 \notag\\
        & \goto{R_2}{1}                 \notag\\[-.3em]
        & R_1 \leftarrow R_1\dotminus 1 \notag
    \end{align}
\end{minipage}
\begin{minipage}{.48\textwidth}
    $ \semRAM_P(n) = 2n $
\end{minipage}

\subsubsection*{Aritmetizzazione di un programma RAM}
Essendo un programma RAM una lista di istruzioni, per poter codificare e decodificare
dei programmi basterà trovare una funzione $Ar$ che codifica le singole istruzioni, 
ottenenendo una lista di numeri che si può facilmente codificare con $\cantor{\ ,\ }$:
\begin{figure}[H]
    \centering
    \input{figures/ram_codifica.tex}
\end{figure}

L'associazione biunivoca di un numero ad una struttura si dice aritmetizzazione o
Gödellizzazione.

\subsubsection*{Aritmetizzazione delle istruzioni RAM}\label{sec:aritm_ram}
Per poter aritmetizzare un'istruzione RAM c'è bisogno di una funzione che:
$$ Ar:\text{Istr}\to\N \quad , \quad Ar^{-1}:\N\to\text{Istr} $$
Il linguaggio RAM è formato da tre tipi di istruzioni; si può quindi ottenere la
seguente aritmetizzazione:
$$ \begin{aligned}
    Ar(R_k\leftarrow R_k+1) &= 3k\\
    Ar(R_k\leftarrow R_k\dotminus1) &= 3k+1\\
    Ar(\goto{R_k}{m}) &= 3\cantor{k,m}-1
\end{aligned} $$
Mentre per calcolare la sua inversa $Ar^{-1}$, ovvero a partire da un numero $n$ decodificare
l'istruzione:
\begin{itemize}
    \item Se $n\bmod{3}=0$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di primo tipo
                \item $n=3k$
            \end{minipage}
            \begin{minipage}{.3\textwidth}
                $\Rightarrow \qquad R_{\frac{n}{3}} \leftarrow R_{\frac{n}{3}}+1$
            \end{minipage}
        \end{itemize}
    \item Se $n\bmod{3}=1$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di secondo tipo
                \item $n=3k+1$
            \end{minipage}
            \begin{minipage}{.3\textwidth}
                $\Rightarrow \qquad R_{\frac{n-1}{3}} \leftarrow R_{\frac{n-1}{3}}\dotminus1$
            \end{minipage}
        \end{itemize}
    \item Se $n\bmod{3}=2$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di terzo tipo
                \item $n=3\cantor{k,m}-1$
            \end{minipage}
            \begin{minipage}{.5\textwidth}
                $\Rightarrow \qquad \goto{R_{\sx(\frac{n+1}{3})}}{\dx(\frac{n+1}{3})}$
            \end{minipage}
        \end{itemize}
\end{itemize}

\subsubsection*{Potenza computazionale del sistema RAM}
$$ \begin{aligned}
        F(\RAM) &= \{f\in\N_\perp^\N:\exists P \in \PROG: \semRAM_P=f\}\\
                &= \{\semRAM_P:P\in\PROG\} \subset \N_\perp^\N \\
                \multispan2{Vista la possibilità di rappresentare un programma
                 con un numero si ha:\hfill}\notag\\
                 &= \{\semRAM_i:i\in\N\}
\end{aligned} $$
Dove $\semRAM_i$ è la semantica del programma la cui codifica è $i$.
\subsubsection*{Conclusioni}
Nelle ultime sezioni si è mostrata una biezione tra programmi RAM (PROG) e numeri
($\N$):
    \begin{itemize}
        \item Da programmi a numeri:
            $cod(P)=\cantor{Ar(\text{Istr}_1),Ar(\text{Istr}_2),\dots,Ar(\text{Istr}_m)}$
        \item Da numeri a programmi: si decodifichi la lista di numeri e si applichi su
            ogni numero $Ar^{-1}$
    \end{itemize}
Per quanto riguarda i programmi RAM, \textbf{si può quindi affermare che}:
$$ F(\RAM) \sim \N \nsim \N^\N_\perp $$
e quindi esistono problemi non risolubili automaticamente da una macchina RAM.
\subsubsection{Sistema di calcolo WHILE}
Per mostrare se il concetto di calcolabilità è legato al sistema di calcolo o meno,
se ne vedrà uno più sofisticato: quello WHILE.
\subsubsection*{Macchina WHILE}
La macchina WHILE è più semplice di quella RAM; è formata infatti da un'unica memoria
con un numero finito di registri:
$$\text{Memoria: } x_0,x_1,x_2,\dots,x_{20}$$
\begin{itemize}
    \item $x_i$ è un generico registro di memoria detto variabile:
        \begin{itemize}
            \item $x_0$ è la variabile specifica dove verrà deposto l'output del programma
            \item $x_1$ è la variabile specifica dove verrà letto l'input del programma
            \item Ci sono 21 variabili
        \end{itemize}
    \item Non c'è un Program Counter
\end{itemize}

\subsubsection*{Linguaggio WHILE}
La sintassi del linguaggio WHILE è induttiva; le istruzioni, dette comandi, sono:
\begin{itemize}
    \item Comando di assegnamento:
        \begin{enumerate}
            \item $x_k := 0$
            \item $x_k := x_j+1$
            \item $x_k := x_j\dotminus 1$
        \end{enumerate}
    \item Comando WHILE:
        \begin{enumerate}
            \item $\while{x_k} C$
        \end{enumerate}
    \item Comando composto:
        \begin{enumerate}
            \item $\textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend$
        \end{enumerate}
    \end{itemize}
dove $C_i$ è un comando WHILE.

Un programma WHILE è un comando composto.

\subsubsection*{Semantica programma WHILE}
La semantica di un programma $W$ è la funzione
    $$\semWHILE_W:\N\to\N_\perp$$
\subsubsection*{Esempio di programma}
\vspace{-1em}
\begin{minipage}{.34\textwidth}
    \begin{align}
        W \equiv\ & \textbegin                      \notag\\[-.3em]
        & \qquad x_2 := x_1+1;                      \notag\\[-.3em]
        & \qquad x_2 := x_2\dotminus 1;             \notag\\[-.3em]
        & \qquad \while{x_1}                        \notag\\[-.3em]
        & \qquad\qquad \textbegin                   \notag\\[-.3em]
        & \qquad\qquad\qquad x_0 := x_0+1;          \notag\\[-.3em]
        & \qquad\qquad\qquad x_1 := x_1\dotminus 1; \notag\\[-.3em]
        & \qquad\ \ \ \ \ \textend                  \notag\\[-.3em]
        & \qquad \while{x_2}                        \notag\\[-.3em]
        & \qquad\qquad \textbegin                   \notag\\[-.3em]
        & \qquad\qquad\qquad x_0 := x_0+1;          \notag\\[-.3em]
        & \qquad\qquad\qquad x_2 := x_2\dotminus 1; \notag\\[-.3em]
        & \qquad\ \ \ \ \ \textend                  \notag\\[-.3em]
        & \hspace{-.5em}\textend                            \notag
    \end{align}
\end{minipage} \hspace{1em}
\begin{minipage}{.6\textwidth}
    $\qquad\qquad\ \ \ \semWHILE_W(n) = 2n $
\end{minipage}

\subsubsection*{W-PROG e induzione}
Sia W-PROG l'insieme dei programmi WHILE. La sua definizione è induttiva; per dimostrare
una proprietà $P$ su W-PROG sarà quindi naturale farlo tramite induzione.

\subsubsection*{Stato}
Siccome la macchina WHILE è composta solo da 21 variabili, uno stato della macchina è
una lista di 21 numeri:
$$ \text{STATO} = (c_0,c_1,\dots,c_{20}) $$
$$ c_i = \text{contenuto di $x_i$} $$
$$ \text{W-STATI} = \N^{21} $$
$$ \underbar{$x$}\in\N^{21} $$

La funzione $W$-$in:\N\to\N^{21}$ restituisce lo stato iniziale del programma $W$:
$$ W\text{-}in(n) = (0,n,0,\dots,0) $$

\subsubsection*{Funzione stato prossimo}
Si definisca la funzione stato prossimo e quindi la semantica operazionale:
$$\opsemWHILE{\ }{\ }: \text{W-COM}\times\text{W-STATI}\to\text{W-STATI}_\perp$$
dato un comando $C$ e uno stato $\underbar{x}$:
$$ \opsemWHILE{C}{\sottolinea{x}} = \sottolinea{y} $$
dove $\sottolinea{y}$ è lo stato prossimo di $\sottolinea{x}$ a seguito dell'esecuzione del
comando $C$.

Si veda ora la definizione induttiva della semantica operazionale:
\begin{itemize}
    \item (BASE) Assegnamenti
        \begin{itemize}
            \item $\opsemWHILE{x_k:=0}{\sottolinea{x}} = \sottolinea{y}$ con
                $y_i = \begin{cases}
                    x_i & i\neq k\\
                    0 & i= k\\
                \end{cases}$
            \item $\opsemWHILE{x_k:=x_j \pm 1}{\sottolinea{x}} = \sottolinea{y}$ con
                $y_i = \begin{cases}
                    x_i & i\neq k\\
                    x_j\pm 1 & i= k\\
                \end{cases} \hfill \text{(con $\pm$ si intende $+$ o $\dotminus$)}$
        \end{itemize}
    \item (PASSO) Comando composto
        \begin{itemize}
            \item $
                \opsemWHILE{\textbegin C_1 \ ; \ \dots \ ; \ C_m\textend}{\sottolinea{x}}
                = \opsemWHILE{C_m}{
                    \dots(
                        \opsemWHILE{C_2}{
                            \opsemWHILE{C_1}{\sottolinea{x}}
                        }
                    )\dots
                }$
            \item[]\hspace{14.1em}$=\opsemWHILEnoP{C_m}\circ\hdots\circ\opsemWHILEnoP{C_1}(\sottolinea{x})$
            \item[]\hspace{14.1em}$=\sottolinea{y}$
        \end{itemize}
    \item (PASSO) Comando WHILE
        \begin{itemize}
            \item $
            \opsemWHILE{\while{x_n} C}{\sottolinea{x}} =
            \opsemWHILE{C}{
                \dots(
                \opsemWHILE{C}{
                    \opsemWHILE{C}{\sottolinea{x}}
                })
                \dots
            }=\sottolinea{y}
            $
            \item[]\hspace{11.7em}$=
                \begin{cases}
                    \opsemWHILEnoP{C}^e(\sottolinea{x}) & e=
                    \mu t(\text{componente $k$ di $\opsemWHILEnoP{C}^t(\sottolinea{x})=0$})\\
                    \perp & \text{altrimenti (se non esiste $e)$}
                \end{cases}
            $
            \\[.6em]dove $\mu t (\text{condizione}) = \underset{t}{\min}\{\text{condizione vera\}}$
        \end{itemize}
\end{itemize}
Si può quindi definire la semantica di un programma $W$:
$$\semWHILE_W(n) = \Pro(0,\opsemWHILE{W}{\text{$W$-$in$}(n)})$$
dove Pro è la funzione proiezione:
$$ \Pro(i,(x_0,x_1,\dots,x_m)) = x_i $$

\subsubsection*{Potenza computazionale del sistema WHILE}
$$ \begin{aligned}
    F(\text{WHILE}) &= \{ f\in\N^\N_\perp : \exists W\in \text{W-PROG}:f=\semWHILE_W \}\\
    &= \{ \semWHILE_W : W \in \text{W-PROG} \} 
    \end{aligned}
$$

\subsubsection{Traduzione}
Dati i sistemi di calcolo $\SC_1$ e $\SC_2$, una traduzione da $\SC_1$ a $\SC_2$ è una funzione
$$ T:\SC_1\text{-PROG}\to\SC_2\text{-PROG} $$
tale che $T$ sia:
\begin{enumerate}
    \item Programmabile: è programmabile effettivamente
    \item Completa: traduce ogni programma
    \item Corretta: mantiene la semantica:
        $\forall P\in\SC_1\text{-PROG} \quad \semRAM_{T(P)}=\semWHILE_{P}$
\end{enumerate}
\subsubsection{Confronto tra sistemi di calcolo}
Si prendano due sistemi di calcolo $\SC_1$ e $\SC_2$ con le rispettive potenze computazionali:
$$ F(\SC_1) = \{\semRAM_{P_1}:P_1\in\SC_1\text{-PROG}\} $$
$$ F(\SC_2) = \{\semWHILE_{P_2}:P_2\in\SC_2\text{-PROG}\} $$

Si vuole mostrare che $F(\SC_1)\subseteq F(\SC_2)$, ovvero che $\SC_1$ non è più potente di $\SC_2$;
per farlo bisogna dimostrare che:
\begin{table}[H]
    \centering
    \begin{tabular}{c}
        $\forall f \in F(\SC_1) \quad f\in F(\SC_2)$\\[1em]
        \rotatebox[origin=c]{90}{$\equiv$}\\[1em]
        $\exists P_1\in\SC_1\text{-PROG}:f=\semRAM_{P_1}
    \ \Rightarrow \ \exists P_2\in\SC_2\text{-PROG}:f=\semWHILE_{P_2}$
    \end{tabular}
\end{table}
In altre parole, per ogni programma di $\SC_1$ ne esiste uno equivalente in $\SC_2$.
\\
\begin{theorem}\label{theo:traduttore}
    Se esiste una traduzione $T$ da $\SC_1$ a $\SC_2$, allora $F(\SC_1)\subseteq F(\SC_2)$.
\end{theorem}
\begin{proof}
    Si prenda una funzione $f$ tale che:
    $$ f\in F(\SC_1) $$
    Si ha quindi che esiste un programma in $\SC_1\text{-PROG}$ che può calcolare $f$:
    \begin{equation} \label{eq:traduzione_proof1}
        \exists P\in\SC_1\text{-PROG}:f=\semWHILE_P
    \end{equation}
    Si prenda la traduzione $T$ da $\SC_1$ a $\SC_2$; vista la completezza di $T$ si ha che:
    \begin{equation} \label{eq:traduzione_proof2}
        T(P)\in\SC_2\text{-PROG}
    \end{equation}
    e vista la correttezza si ha che:
    \begin{equation} \label{eq:traduzione_proof3}
        \semRAM_{T(P)}=\semWHILE_P\underset{(\ref{eq:traduzione_proof1})}{=}f
    \end{equation}
    Si ha quindi che esiste un programma $T(P)$ in $\SC_2$-PROG (\ref{eq:traduzione_proof2})
    la cui semantica è $f$ (\ref{eq:traduzione_proof3}). Si può concludere che:
    $$ f\in F(\SC_2) $$ 
\end{proof}

\textbf{Quindi, per mostrare che un sistema di calcolo $\SC_1$ non è più potente di un 
altro sistema $\SC_2$, basterà trovare una traduzione da $\SC_1$ a $\SC_2$}. 

\subsubsection{\texorpdfstring{$\bm{F(\text{WHILE})\subseteq F(\text{RAM})}$}
{F(WHILE) sottoinsieme F(RAM)}}\label{sec:FwhileFram}
In questa sezione si mostrerà che il una macchina WHILE \textbf{non} è più potente di
una macchina RAM. Per farlo, come suggerisce il teorema \ref{theo:traduttore}, verrà
mostrata una traduzione da W-PROG a PROG; la funzione di traduzione viene detta
compilatore:
$$ Comp:\text{W-PROG}\to\text{PROG} $$
Per comodità si userà un linguaggio RAM etichettato, dove nell'istruzione di \texttt{GOTO}
si useranno delle etichette e non il numero dell'istruzione. Questo non influenzerà
in alcun modo la potenza del linguaggio.

\subsubsection*{Compilatore}
Vista la natura induttiva di W-PROG, anche $Comp$ verrà definita induttivamente:
\begin{enumerate}
    \item (BASE) Compilazione degli assegnamenti:
        \begin{itemize}
            \renewcommand{\labelitemi}{\raisebox{5.8\height}{\textbullet}}
            \item
                \renewcommand{\arraystretch}{1.25}
                \begin{tabular}{l|r l|}\cline{2-3}
                $Comp(x_k:=0)=$ & \texttt{LP}:&$\goto{R_k}{\texttt{EX}}$\\
                && $R_k\leftarrow R_k\dotminus 1$ \\
                && $\goto{R_{21}}{\texttt{LP}}$ \\
                &\texttt{EX}:& $R_k \leftarrow R_k\dotminus 1$ \\\cline{2-3}
                \end{tabular}\vspace{.15cm}
            \renewcommand{\labelitemi}{\textbullet}
            \item $\ \ Comp(x_k:=x_j+/\dotminus 1) \ $=
                \begin{itemize}
                    \renewcommand{\labelitemii}{\raisebox{.1\height}{$-$}}
                    \item \renewcommand{\arraystretch}{1.25}
                        \begin{tabular}{r|l|} \cline{2-2}
                         Se $k=j$: &$R_k \leftarrow +/\dotminus 1$\\ \cline{2-2}
                        \end{tabular}
                    \renewcommand{\labelitemii}{\raisebox{15.5\height}{$-$}}
                    \item
                        \renewcommand{\arraystretch}{1.25}
                        \begin{tabular}{l|r l|l}\cline{2-3}
                         Se $k\neq j$: & \texttt{LP}:&$\goto{R_j}{\texttt{E1}}$
                                &\multirow{4}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$ Salva $R_j$ in $R_{22}$
                                }\\
                        && $R_{22}\leftarrow R_{22}+1$ \\
                        && $R_{j}\leftarrow R_{j}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{LP}}$ \\
                        &\texttt{E1}:& $\goto{R_k}{\texttt{E2}}$
                                &\multirow{3}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$ Azzera $R_k$
                                }\\
                        && $R_{k}\leftarrow R_{k}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{E1}}$ \\
                        &\texttt{E2}:& $\goto{R_{22}}{\texttt{E3}}$
                                &\multirow{5}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$  Rigenera $R_j$ e $R_k$ da $R_{22}$ 
                                }\\
                        && $R_{k}\leftarrow R_{k}+1$ \\
                        && $R_{j}\leftarrow R_{j}+1$ \\
                        && $R_{22}\leftarrow R_{22}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{E2}}$ \\
                        &\texttt{E3}:& $R_k\leftarrow R_k+/\dotminus 1$ \\ \cline{2-3}
                        \end{tabular}\vspace{.5cm}
                \end{itemize}
        \end{itemize}
    \item (PASSO) Per ipotesi induttiva si assumi data la compilazione di un comando
        $C$:
        \begin{enumerate}
            \item Compilazione di comando composto:
                \begin{itemize}
                    \renewcommand{\labelitemi}{\raisebox{6.6\height}{\textbullet}}
                    \item \renewcommand{\arraystretch}{1.25} 
                        \begin{tabular}{l| l|}\cline{2-2}
                        $Comp(\textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend)=$&
                            $Comp(C_1)$\\
                            & $Comp(C_2)$\\
                            & $\vdots$\\
                            & $Comp(C_m)$\\ \cline{2-2}
                    \end{tabular}
                \end{itemize}
            \item Compilazione di comando WHILE:
                \begin{itemize}
                    \renewcommand{\labelitemi}{\raisebox{6\height}{\textbullet}}
                    \item \renewcommand{\arraystretch}{1.25} 
                        \begin{tabular}{l|r l|}\cline{2-3}
                        $Comp(\while{x_k}C)$ =& \texttt{LP}:&
                            $\goto{R_k}{\texttt{EX}}$\\
                            && $Comp(C)$\\
                            && $\goto{R_{21}}{\texttt{LP}}$\\
                            &\texttt{EX}:& $R_k\leftarrow R_k\dotminus 1$\\ \cline{2-3}
                    \end{tabular}
                \end{itemize}
        \end{enumerate}
\end{enumerate}

\subsubsection*{Conclusioni}
La funzione $Comp:\text{W-PROG}\to\text{PROG}$ precedentemente definita soddisfa le tre
condizioni di una traduzione:
\begin{enumerate}
    \item È programmabile
    \item Compila sempre
    \item Mantiene la semantica
\end{enumerate}

Si ha quindi che $Comp$ è una traduzione da W-PROG a PROG e che:
$$ F(\text{WHILE})\subseteq F(\text{RAM}) $$

\subsubsection{\texorpdfstring{$\bm{F(\text{RAM})\subseteq F(\text{WHILE})}$}
{F(RAM) sottoinsieme F(WHILE)}}\label{sec:FramFwhile}
Ora che si è mostrato che una macchina WHILE non è più potente di una RAM, si mostrerà
l'inverso.

Per farlo si userà il concetto di interprete.
\subsubsection*{Interprete}
A differenza di un compilatore un interprete non produce nessun oggetto ma esegue
direttamente tutte le istruzioni del programma. In altre parole, un interprete è
un programma che prende in ingresso un altro programma $P$ e un dato $x$ e restituisce
il risultato della semantica di $P$ su $x$ ovvero $\semRAM_P(x)$.

\subsubsection*{Interprete WHILE di programmi RAM}
Si definirà ora un interprete $I_W$ scritto in WHILE di programmi RAM.
\begin{figure}[h]
    \centering
    \input{figures/interprete1.tex}
\end{figure}

\begin{tabular}{l p{.83\textwidth}}
    Problema:& un programma WHILE prende in input solo numeri; non è in grado di leggere 
    un programma RAM \quotes{puro}. $P$\\[1.6em]
    Soluzione:& codifico $P$ in un numero $n$.
\end{tabular}
\begin{figure}[h]
    \centering
    \input{figures/interprete2.tex}
\end{figure}

\begin{tabular}{l p{.83\textwidth}}
    Problema:& un programma WHILE prende in input solo un numero.\\[.5em]
    Soluzione:& aggrego $n$ e $x$ tramite la funzione coppia di Cantor.
\end{tabular}
\begin{figure}[h]
    \centering
    \input{figures/interprete3.tex}
\end{figure}

La semantica dell'interprete $I_W$ è:
$$\forall x,n\in\N: \semWHILE_{I_W}(\cantor{x,n})
=\semRAM_n(x)=\semWHILE_P(x)$$

Per questioni di comodità si usera una variante di WHILE in cui si potranno definire
delle macro, ovvero delle chiamate a funzioni comunque definibili in WHILE puro; alcuni
esempi di macro sono:
\begin{itemize}
    \item $x_k:=x_j+x_s$
    \item $x_k:=\cantor{x_j,x_s}$\hfill coppia di Cantor
    \item $x_k:=\cantor{a_1,a_2,\dots,a_N}$\hfill \quotes{lista di Cantor}
    \item $x_k:=\Pro(x_j,x_s)$ \hfill estrae dalla lista codificata $x_s$ il
        $x_j$-esimo elemento
    \item $x_k:=\text{incr}(x_j,x_s)$\hfill codifica la lista $x_s$ in cui il $x_j$-esimo elemento
        viene incrementato di 1
    \item $x_k:=\text{decr}(x_j,x_s)$\hfill codifica la lista $x_s$ in cui il $x_j$-esimo elemento
    viene decrementato di 1
    \item $x_k:=\sx(x_j)$\hfill estrae l'elemento sinistro dalla codifica di Cantor $x_j$
    \item $x_k:=\dx(x_j)$\hfill estrae l'elemento destro dalla codifica di Cantor $x_j$
    \item \texttt{if}$\dots$\texttt{then}$\dots$\texttt{else}
\end{itemize}

\subsubsection*{Stato della macchina RAM nell'interprete}
L'interprete $I_W$ per eseguire il programma $P$ ricrea nelle sue variabili lo stato
della macchina RAM in cui verrebbe eseguito $P$.

\begin{tabular}{l p{.83\textwidth}}
    Problema:& la macchina RAM ha infiniti registri mentra quella WHILE ne ha ventuno.
        \\[.5em]
    Soluzione:& un programma $P$ userà sempre un numero finito di registri il cui contenuto
        può essere racchiuso in una lista di valori $a_0,a_1,\dots,a_n$; la soluzione
        consiste nel raggruppare tutti i valori dei registri tramite Cantor:
        $$ \cantor{a_1,a_2,\dots,a_n} $$ e salvarne la codifica in un unica variabile.
\end{tabular}

$I_W$ salva lo stato della macchina RAM nel seguente modo:
\begin{itemize}
    \item $x_0 \leftarrow \cantor{R_0,\dots,R_{n}}$\hfill
        stato della memoria RAM del programma P con $cod(P)=n$
    \item $x_1 \leftarrow L$ \hfill program counter
    \item $x_2 \leftarrow x$ \hfill dato di input del programma $P$
    \item $x_3 \leftarrow n$ \hfill lista di istruzioni che formano $P$
    \item $x_4 \leftarrow \text{codice dell'istruzione da eseguire}$
\end{itemize}

Si noti come il valore di $n$ (primo punto), ovvero dell'indice del registro più alto 
presente nel programma $P$, sia direttamente il valore della codifica di $P$. Questo
perchè $n$ vuole essere un limite superiore dell'indice più alto presente in $P$ e non
un valore esatto.

\subsubsection*{Implementazione}
Verrà mostrata ora l'implementazione dell'interprete $I_W$ scritto in (macro-)WHILE di un
programma RAM $P$:
$$ \semWHILE_{I_W}(\cantor{x,n})=\semRAM_n(x) $$
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.3mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetArgSty{relax}
    \SetAlgoNoEnd
    \SetKwSty{texttt}
    \tcp{Inizialmente l'input si trova in $x_1$}
    $x_2 := \sx(x_1)$\;
    $x_3 := \dx(x_1)$\;
    $x_0 := \cantor{0,x_2,\dots,0}$\;
    $x_1 := 1$\;
    \While(\hfill\texttt{// se $x_1=0$ allora STOP}){$x_1\neq 0$}{
        \eIf(\hfill\texttt{// supero l'ultima istruzione}){($x_1>\text{length($x_3$))}$}{
            $x_1:=0$\tcp*{STOP}
        }{
            $x_4 := \Pro(x_1,x_3)$\tcp*{estraggo istruzione corrente}
            \If(\hfill\texttt{// }$R_k\leftarrow R_k+1$){$x_4\bmod{3}=0$}{
                $x_5 := x_4 / 3$\tcp*{$k$}
                $x_0 := \text{incr}(x_5,x_0)$\;
                $x_1 := x_1+1$\;
            }
            \If(\hfill\texttt{// }$R_k\leftarrow R_k\dotminus1$){$x_4\bmod{3}=1$}{
                $x_5 := (x_4-1) / 3$\tcp*{$k$}
                $x_0 := \text{decr}(x_5,x_0)$\;
                $x_1 := x_1+1$\;
            }
            \If(\hfill\texttt{// }$\goto{R_k}{m}$){$x_4\bmod{3}=2$}{
                $x_5 := \sx((x_4+1)/3)$\tcp*{$k$}
                $x_6 := \dx((x_4+1)/3)$\tcp*{$m$}
                \eIf(\hfill\texttt{// verifico }$R_k=0$){Pro$(x_5,x_0)=0$}{
                    $x_1:=x_6$\;
                }{
                    $x_1:=x_1+1$\;
                }
            }
        }
    }
    $x_0 = \sx(x_0)$\tcp*{metto in $x_0$ il risultato $\semRAM_n(x)$}
\end{algorithm}
\end{tcolorbox}

\subsubsection*{Conclusioni}
L'esistenza di $I_W$ permette la costruzione immediata di un compilatore:
$$ Comp:\text{PROG\ $\to$ W-PROG} $$

\renewcommand{\arraystretch}{1.25}
\begin{center}
\begin{tabular}{r|l|} \cline{2-2}
 $Comp(P)=$ & $n\leftarrow cod(P);$\\
            & $x_1 := \cantor{x_1,n};$\\
            & $I_W;$ \\ \cline{2-2}
\end{tabular}
\end{center}\vspace{.5cm}

$Comp$ non fa altro che mettere in $x_1$ il dato $x$ (già presente nella variabile $x_1$) e 
il programma codificato in $n$ aggregati tramite $\cantor{x,n}$ e far partire l'interprete 
$I_W$ che restituirà in $x_0$ il risultato della computazione.

Si è quindi appena dimostrata l'esistenza di una traduzione da RAM a WHILE che implica che:
$$ \text{$F$(RAM) $\subseteq$ $F$(WHILE)} $$

\subsubsection{Teorema di Böhm-Jacopini}
I risultati delle sezioni \ref{sec:FwhileFram} e \ref{sec:FramFwhile} permettono di dire
che:
$$ \begin{matrix}
    F(\text{RAM})\subseteq F(\text{WHILE}) \\
    F(\text{RAM})\supseteq F(\text{WHILE}) \\
\end{matrix} \quad \Rightarrow \quad
 F(\text{RAM})=F(\text{WHILE}) $$

\begin{theorem}[Böhm-Jacopini]
    Per ogni programma con il comando \texttt{GOTO} (RAM) ne esiste uno equivalente in
    linguaggio strutturato (WHILE)
\end{theorem}

Questo teorema, enunciato nel 1966 da due informatici italiani, rappresenta un risultato
cruciale dell'informatica: mostra infatti che:
\begin{enumerate}
    \item Il comando di \texttt{GOTO} ha solo nati negativi e non è necessario;
    \item La programmazione a basso livello può essere sostituita da quella ad alto
        livello.
\end{enumerate}

Concludendo, si è anche dimostrato che:
$$ F(\text{RAM})=F(\text{WHILE}) \sim \N \nsim \N^\N_\perp $$
\textbf{Esistono quindi funzioni non computabili da entrambi i sistemi}.

\subsubsection{Interprete universale}\label{sec:interpreteU}
Si prenda il compilatore $Comp:\text{W-PROG}\to\text{PROG}$ e lo si utilizzi con $I_W$:
$$ \semWHILE_{I_W}(\cantor{x,n})=\semRAM_n(x) $$
$$ U = Comp(I_W)\in\text{PROG} $$
$U$ è detto interprete universale ed è un programma RAM in grado di simulare qualsiasi
altro programma RAM.
La sua semantica è:
$$ \semRAM_U(\cantor{x,n})=\semWHILE_{I_W}(\cantor{x,n})=\semRAM_n(x) $$

\subsection{Calcolabilità}
Nelle sezioni precedenti si è visto come due sistemi di calcolo molto diversi tra loro 
abbiano la stessa potenza computazionale numerabile:
$$ F(\text{RAM}) = F(\text{WHILE}) \sim \N \nsim \N^\N_\perp$$
e che quindi esistono delle funzioni non calcolabili da questi sistemi. Torna però qui la
questione: \quotes{E se esistesse un altro sistema di calcolo più potente?}

Bisognerà affrontare il problema a prescindere dalla macchina usata, definendo la 
calcolabilità in termini più matematici e \quotes{lontani} dall'informatica.

\subsubsection{Una prima idea di calcolabilità}
Per introdurre la definizione \quotes{teorica} di calcolabilità si introducano due insiemi:
\begin{itemize}
    \item $\elem$: insieme di tre funzioni molto semplici e banalmente implementabili;
    \item $\Omega$: insieme di operazioni su funzioni banalmente implementabili;
\end{itemize}

L'idea è che applicando un operazione facilmente calcolabile di $\Omega$ ad una funzione
facilmente calcolabile di $\elem$ ottengo un'altra funzione facilmente calcolabile:
$$ \elem^\Omega = \ricPar $$
$\ricPar$ è la classe delle funzioni ricorsive parziali e vuole essere una prima 
idea di classe di funzioni calcolabili. \textbf{Bisognerà ora capire quali funzioni compongono 
$\elem$ e quali operatori compongono $\Omega$}.

$\elem$ è composto da tre funzioni:

\begin{tabular}{l r l r l}
    $\elem =$ & $\{ \ \text{successore:}$ & $s(x)=x+1\ ,$&$x\in\N$ &\\
              & $\text{zero:}$ & $O^n(x_1,\dots,x_n)=0\ ,$&$x_i\in\N$ &\\
              & $\text{proiettori:}$ & $\text{pro}^n_k(x_1,\dots,x_n)=x_k\ ,$&$x_i\in\N$&
                \hspace{-.3cm}$\}$ \\
\end{tabular}

Le funzioni appena mostrare di $\elem$ devono essere incluse in un'idea di calcolabile:
sono proprio banali e semplici. Tuttavia ci saranno anche altre funzioni sicuramente calcolabili;
basti pensare che $f(x)=x+2$ non è presente in $\elem$ ma è certamente calcolabile.

Si deve quindi ampliare $\elem$ mantenendo sempre un'idea intuitiva di calcolabile: si
introdurrano gli operatori di composizione di funzioni e di ricorsione primitiva.

\subsubsection*{Operatore di composizione di funzioni}
Siano:
$$\begin{aligned}
    h:&\ \N^k\to\N \\
    g_1,\dots,g_k:&\ \N^n\to\N \\
    \sottolinea{x}\in&\ \N^n
\end{aligned}$$
Si definisce la composizione di funzioni come:
$$\comp(h,g_1,\dots,g_k):\ \N^n\to\N$$
$$\comp(h,g_1,\dots,g_k)(\sottolinea{x}) = h(g_1(\sottolinea{x}),\dots,g_k(\sottolinea{x}))$$

\begin{center}
    \input{figures/comp_function.tex}
\end{center}

Si ampli $\elem$ chiudendolo rispetto a $\comp$:
$$ \elem^\comp $$
$\elem$ viene ampliato; si può notare infatti che:
\begin{itemize}
    \item $f(x)=x+2 \notin \elem$
    \item $f(x)=x+2 \in \elem^\comp$ infatti $f(x)=\comp(s,s)(x)=s(s(x))=s(x+1)=x+2$
\end{itemize}
Tuttavia questo ampliamento non basta: $\elem^\comp$ infatti non contiene funzioni banali come
$\text{somma}(x,y)=x+y\notin\elem^\comp$.

\subsubsection*{Operatore di ricorsione primitiva}
Quest'operatore permette di definire funzioni ricorsive come:
$$ fatt(n) = \begin{cases}
    1 & n=0\\
    n*fatt(n-1) & n>0
\end{cases} $$

Siano:
\begin{center}
    \begin{tabular}{c l}
        $g:\ \N^n\to\N$ & funzione da applicare alla base ricorsiva\\
        $h:\ \N^{n+2}\to\N$ & funzione da applicare nel passo ricorsivo\\
        $g(\sottolinea{x})\ ,\ h(z,y,\sottolinea{x})$ con $\sottolinea{x}\in\N^n$\\
    \end{tabular}
\end{center}

Si definisce l'operatore di ricorsione primitiva:
$$ \RP(h,g) = f(\sottolinea{x},y) = \begin{cases}
    g(\sottolinea{x}) & y=0\\
    h(f(\sottolinea{x},y-1),y-1,\sottolinea{x}) & y>0
\end{cases}$$

Si noti che nel passo ricorsivo $h(f(\sottolinea{x},y-1),y-1,\sottolinea{x})$ non è detto
debbano essere gli ultimi due argomenti della funzione $h$.

\subsubsection{Funzioni ricorsive primitive}
Si ampli $\elem^\comp$ chiudendolo rispetto a $\RP$:
$$ \elem^{\comp,\RP} = \ricPrim $$
$\elem^{\comp,\RP}$ è formato dalle funzioni ricorsive primitive.

Alcuni esempi di funzioni ricorsive primitive sono:
$$\begin{aligned}
    \text{somma}(x,y) &= \RP({\color{blue}s},\text{pro}^1_1)\\
    &= \begin{cases}
        \text{pro}_1^1(x) & y=0\\
        {\color{blue}s}(\text{somma}(x,y-1),{\color{red}y-1},{\color{red}x}) & y>0
    \end{cases}\\
    &= \begin{cases}
        x & y=0\\
        {\color{blue}s}(\text{somma}(x,y-1)) & y>0
    \end{cases}\\[1em]
    \text{prodotto}(x,y) &= \RP({\color{blue}\text{somma}},O^1)\\
    &= \begin{cases}
        O^1(x) & y=0\\
        {\color{blue}\text{somma}}(\text{prodotto}(x,y-1),{\color{red}y-1},x) & y>0
    \end{cases}\\
    &= \begin{cases}
        0 & y=0\\
        {\color{blue}\text{somma}}(\text{prodotto}(x,y-1),x) & y>0
    \end{cases}\\[1em]
    \text{predecessore}(x) &= P(x) = \begin{cases}
        0 & x=0 \\ x-1 & x>0
    \end{cases}\\
    \dotminus(x,y)=x\dotminus y &= \RP({\color{blue}P},\text{pro}_1^1)\\
    &= \begin{cases}
        \text{pro}^1_1(x) & y=0\\
        {\color{blue}P}(\dotminus(x,y-1),{\color{red}y-1},{\color{red}x}) & y>0
    \end{cases}\\
    &= \begin{cases}
        x & y=0\\
        {\color{blue}P}(\dotminus(x,y-1)) & y>0
    \end{cases}
\end{aligned}$$

Si noti, come anticipato, che alcuni argomenti del passo ricorsivo {\color{red} possono non
essere usati} dalla funzione {\color{blue}$h$}

\subsubsection*{RICPRIM vs F(WHILE)}

RICPRIM contiene molte funzioni; si mostrerà ora che tutte le funzioni ricorsive primitive
possono essere calcolate da una macchina WHILE, ovvero:
$$ \ricPrim \subseteq F(\text{WHILE}) $$

La dimostrazione è fatta tramite induzione strutturale a partire dalla definizione di
$\ricPrim=\elem^{\comp,\RP}$:
\begin{enumerate}
    \item (BASE) Le funzioni in $\elem$ sono in $\ricPrim$
    \item (PASSO) $h,g_1,\dots,g_k\in\ricPrim \ \Rightarrow \ \comp(h,g_1,\dots,g_k)\in\ricPrim$
    \item (PASSO) $g,h\in\ricPrim \ \Rightarrow \ \RP(h,g)\in\ricPrim$
    \item Nient'altro è in $\ricPrim$
\end{enumerate}\label{sec:ricprim_while}
\vspace{1em}

Per dimostrare che $\ricPrim \subseteq F(\text{WHILE})$:
\begin{enumerate}
    \item Dimostro che $\elem\subseteq F(\text{WHILE})$, ovvero mostro per ogni funzione 
    $f\in\elem$ un programma $W\in W\text{-PROG}$ tale che $\semWHILE_W=f$:
    \begin{itemize}
        \item $s(x)=x+1$:
        \begin{minipage}{.27\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := x_1+1$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
        \item $O^n(x_1,\dots,x_n)=0$:
        \begin{minipage}{.23\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := 0$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
        \item $\text{pro}^n_k(x_1,\dots,x_n)=x_k$:
        \begin{minipage}{.32\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := \Pro(k,x_1)$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
    \end{itemize}
    \item Assumo che $h,g_1,\dots,g_k\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G_1,\dots,G_k\in W\text{-PROG}$ tali che:
        $$ \semWHILE_H=h \ ,\ \semWHILE_{G_1}=g_1\ ,\ \dots \ ,\
        \semWHILE_{G_k}=g_k $$
        e dimostro che $\comp(h,g_1,\dots,g_k)\in F(\text{WHILE})$ ovvero mostro un programma
        WHILE che calcola:
        $$\comp(h,g_1,\dots,g_k)=h(g_1(\sottolinea{x}),\dots,g_k(\sottolinea{x}))$$
        \begin{center}
        \begin{minipage}{.85\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
        \begin{algorithm}[H]
            \setstretch{1.2}
            \SetKwSty{texttt}
            \SetKwProg{begin}{begin}{}{end}
            \begin{\hfill{\texttt{// }$x_1\leftarrow\sottolinea{x}=\cantor{a_1,\dots,a_n}$}}{
                $x_0 := G_1(x_1)$\;
                $x_0 := [x_0,G_2(x_1)]$\tcp*{Accoda $G_2(\sottolinea{x})$ all'array $x_0$}
                $\ \vdots$\\
                $x_0 := [x_0,G_k(x_1)]$\tcp*{$x_0:=[G_1(\sottolinea{x}),\dots,G_k(\sottolinea{x})]$}
                $x_0 := H(x_0)$\tcp*{$x_0:=H(G_1(\sottolinea{x}),\dots,G_k(\sottolinea{x}))$}
            }
        \end{algorithm}
        \end{tcolorbox}
        \end{minipage}
        \end{center}
    \begin{minipage}{.9\textwidth}
        \begin{algorithm}[H]
            \SetKwProg{begin}{begin}{}{end}

        \end{algorithm}
    \end{minipage}
    \item Assumo che $g,h\in F(\text{WHILE})$ ovvero che esistono dei programmi
    $H,G\in W\text{-PROG}$ tali che:
    $$ \semWHILE_H=h \ ,\ \semWHILE_{G}=g $$ 
    e dimostro che 
    $\RP(h,g)\in F(\text{WHILE})$ ovvero mostro un programma WHILE che calcola:
    $$ \RP(h,g) = f(\sottolinea{x},y) = \begin{cases}
    g(\sottolinea{x}) & y=0\\
    h(f(\sottolinea{x},y-1),y-1,\sottolinea{x}) & y>0
    \end{cases}$$
    \begin{center}
    \begin{minipage}{.85\textwidth}
    \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
    \begin{algorithm}[H]
        \setstretch{1.2}
        \SetKwSty{texttt}
        \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
        \tcp{Parto dalla base e salgo}
        \tcp{$x_1\leftarrow\cantor{\sottolinea{x},y}$}
        \begin{}{
            $t := G(\sottolinea{x})$\;
            $k := 1$\tcp*{$k$ mi dice a che punto sono}
            {\SetAlgoNoEnd
            \While(\hfill\texttt{// finchè $k$ non raggiunge $y$}){$k\leq y$}{
                \begin{}{
                    $t := H(t,k-1,\sottolinea{x})$\;
                    $k:=k+1$\;
                }
                \texttt{end}\;
            }}
        }
    \end{algorithm}
    \end{tcolorbox}
    \end{minipage}
    \end{center}\vspace{1em}
\end{enumerate}

Dunque per induzione strutturale si è dimostrato che:
$$ \ricPrim \subseteq F(\text{WHILE}) $$

Tuttavia resta la domanda sull'inclusione appena dimostrata: è propria?

Per rispondere basta notare che \textbf{$\ricPrim$ contiene solo funzioni totali}. La 
dimostrazione è semplice e si basa sulla definizione induttiva di $\ricPrim$:
\begin{itemize}
    \item (BASE) Le funzioni di $\elem$ sono totali;
    \item (PASSO) La composizione di funzioni totali è una funzione totale;
    \item (PASSO) La ricorsione primitiva di funzioni totali è una funzione totale: si ha sempre
        un caso base e per definzione si parte da $y$ e si decrementa di 1 fino ad arrivare a 0.
\end{itemize}

\textbf{$F(\text{WHILE})$ invece contiene anche funzioni parziali grazie ai suoi loop che possono
non terminare.}

Si ha quindi che:
$$ \bm{\ricPrim \subset F(\text{WHILE})} $$

\textbf{$\ricPrim$ quindi non basta a rappresentare il concetto di calcolabilità: bisogna 
ampliarlo introducendo una nuova operazione.}

\subsubsection*{Sistema di calcolo FOR}
Partendo dal linguaggio WHILE Si può introdurre un nuovo linguaggio, identico a quello WHILE,
ma che cambia l'istruzione di ciclo: viene usata l'istruzione, ben conosciuta, di
ciclo \texttt{for}:

\begin{center}
\begin{minipage}{.43\textwidth}
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetKwSty{texttt}
    \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
    \begin{}{
        $t := G(\sottolinea{x})$\;
        $k := 1$\;
        {\SetAlgoNoEnd
        \While{$k\leq y$}{
            \begin{}{
                $t := H(t,k-1,\sottolinea{x})$\;
                $k:=k+1$\;
            }
            \texttt{end}\;
        }}
    }
\end{algorithm}
\end{tcolorbox}
\end{minipage}
\begin{minipage}{.1\textwidth}
    \hspace{1.5em}$\to$
\end{minipage}
\begin{minipage}{.43\textwidth}
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetArgSty{relax}
    \SetKwSty{texttt}
    \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
    \begin{}{
        $t := G(\sottolinea{x})$\;
        {\SetAlgoNoEnd
        \For{$k:=1$\texttt{ to }$y$}{
            $t := H(t,k-1,\sottolinea{x})$\;
        }}
    }
\end{algorithm}
\end{tcolorbox}
\end{minipage}
\end{center}

dove la variabile usata dal \texttt{for} non può essere toccata. Il linguaggio che ne deriva
viene chiamato linguaggio FOR e si può dire che:
$$ \ricPrim = F(\text{FOR}) \subset F(\text{WHILE}) $$

\subsubsection{Funzione di Ackermann}
Come già visto, $F(\text{WHILE})$ contiene delle funzioni parziali che $\ricPrim$ non ha.
Queste funzioni parziali derivano dalla possibiliità del linguaggio WHILE di ottenere dei
loop che non terminano. Sembra quindi che se si togliesse la possibilità di eseguire un loop
infinito dal linguaggio WHILE otterremmo $\ricPrim$.

Si prenda il linguaggio WHILE privato della possibilità di eseguire loop infiniti:
$$ \widetilde{F}(\text{WHILE}) = 
    \{\semWHILE_W:W\in W\text{-PROG}\ \wedge\ \semWHILE_W\text{ è totale}\} $$
Si ha che:
$$ \ricPrim\subseteq\widetilde{F}(\text{WHILE}) $$

È un'inclusione propria? \textbf{La risposta è sì.}

Per dimostrarlo si deve mostrare una funzione calcolabile in WHILE che non è ricorsiva primitiva.
Questa funzione è la funzione di Ackermann (1928):
$$ \mathscr{A}(m,n) = \begin{cases}
    n+1 & m=0\\
    \mathscr{A}(m-1,1) & m>0,n=0\\
    \mathscr{A}(m-1,\mathscr{A}(m,n-1)) & m,n>0
\end{cases} $$
Non si entrerà nel dettaglio ma basti sapere che $\mathscr{A}$ cresce troppo in fretta per poter
essere ricorsiva primitiva.

\textbf{Questo mostra che il sistema WHILE è più potente delle funzioni in $\ricPrim$ anche
escludendo gli \quotes{inutili} cicli infiniti}.

\subsubsection{RICPRIM non basta}
La ricerca delle funzioni calcolabili ha portato fin'ora all'insieme delle funzioni ricorsive
primitive $\ricPrim$ che, però, non si è dimostrato all'altezza mostrando \quotes{alcune lacune}
(Ackermann). Si dovrà quindi, ancora una volta, procedere con un ampliamento di $\ricPrim$.

\begin{center}
    \input{figures/calcolabilita1.tex}
\end{center}
\vspace{1em}

\subsubsection*{Operatore di minimalizzazione di funzioni}
Sia:
$$ f:\N^{n+1}\to\N $$
$$ f(\sottolinea{x},y)\text{ con }\sottolinea{x}\in\N^n $$
si definisce operatore di minimalizzazione di una funzione:
$$ \begin{aligned}
    \MIN(f)(\sottolinea{x}) = g(\sottolinea{x}) &=
    \begin{cases}
    y & f(\sottolinea{x},y)=0\ \wedge \ (\forall y'<y:f(\sottolinea{x},y')\termina\ 
    \wedge \ f(\sottolinea{x},y')\neq0)\\
    \perp & \text{altrimenti}
    \end{cases}\\
    &= \mu y(f(\sottolinea{x},y)=0)
\end{aligned}$$

A parole, $\MIN$ restituisce una funzione $g$ la quale restituisce il valore di $y$ più piccolo
che, fissata $\sottolinea{x}$, azzera $f(\sottolinea{x},y)$ o $\perp$ se non esiste un valore
che azzera $f(\sottolinea{x},y)$.

Alcuni esempi dell'applicazione di $\MIN$ sono:
\begin{center}
    \begin{tabular}{c|c}
        $\bm{f(x,y)}$ & $\bm{\textbf{\MIN}(f)(x)=g(x)}$\\ \hline
        $x+y+1$ & $\perp$\\
        $x\dotminus y$ & $x$\\
        $y\dotminus x$ & $0$\\
        $x\dotminus y^2$ & $\left\lceil\sqrt{x}\right\rceil$\\
        $\left\lfloor\frac{x}{y}\right\rfloor$ & $\perp$\\
    \end{tabular}
\end{center}

\subsubsection{Funzioni ricorsive parziali}
Come già fatto precedentemente si ampli $\ricPrim$ chiudendo $\ricPrim=\elem^{\comp,\RP}$
rispetto alla nuovo operazione introdotta $\MIN$:
$$ \elem^{\comp,\RP,\MIN} = \ricPar $$
Le funzioni di $\ricPar$ sono dette funzioni ricorsive parziali.

Sicuramente $\ricPar$ è più grande di $\ricPrim$ vista la presenza di funzioni parziali. Ma che
rapporto ha $\ricPar$ con $F(\text{WHILE})$?

\begin{theorem}\label{th:ricParWhile}
    $\ricPar \subseteq F(\text{WHILE})$
\end{theorem}
\begin{proof}
    Si usi l'induzione strutturale su $\ricPar=\elem^{\comp,\RP,\MIN}$, che può essere definito
    induttivamente:
    \begin{enumerate}
        \item Le funzioni di $\elem$ sono in $\ricPar$
        \item $h,g_1,\dots,g_k\in\ricPar\ \Rightarrow\ \comp(h,g_1,\dots,g_k)\in\ricPar$
        \item $h,g\in\ricPar\ \Rightarrow\ \RP(h,g)\in\ricPar$
        \item $f\in\ricPar\ \Rightarrow\ \MIN(f)\in\ricPar$
        \item Null'altro è in $\ricPar$
    \end{enumerate}
    Per dimostrare che $\ricPar \subseteq F(\text{WHILE})$:
    \begin{enumerate}
    \item Dimostro che $\elem\subseteq F(\text{WHILE})$, ovvero mostro per ogni funzione 
    $f\in\elem$ un programma $W\in W\text{-PROG}$ tale che $\semWHILE_W=f$: già visto
    nella sezione \ref{sec:ricprim_while}
    \item Assumo che $h,g_1,\dots,g_k\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G_1,\dots,G_k\in W\text{-PROG}$ tali che:
        $$ \semWHILE_H=h \ ,\ \semWHILE_{G_1}=g_1\ ,\ \dots \ ,\
        \semWHILE_{G_k}=g_k $$
        e dimostro che $\comp(h,g_1,\dots,g_k)\in F(\text{WHILE})$: già visto nella sezione
        \ref{sec:ricprim_while}.
    \begin{minipage}{.9\textwidth}
        \begin{algorithm}[H]
            \SetKwProg{begin}{begin}{}{end}

        \end{algorithm}
    \end{minipage}
    \item Assumo che $g,h\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G\in W\text{-PROG}$ tali che:
        $$ \semWHILE_H=h \ ,\ \semWHILE_{G}=g $$ 
        e dimostro che 
        $\RP(h,g)\in F(\text{WHILE})$: già visto nella sezione \ref{sec:ricprim_while}.
    \item Assumo che $f\in F(\text{WHILE})$ ovvero che esiste un programma $\mathcal{F}\in
        F(\text{WHILE})$ tale che $\semWHILE_\mathcal{F}=f$
        e dimostro che $\MIN(f)\in F(\text{WHILE})$ ovvero mostro un programma WHILE
        che calcola:
        $$ \begin{aligned}
            \MIN(f)(\sottolinea{x}) = g(\sottolinea{x}) &=
            \begin{cases}
                \mu y(f(\sottolinea{x},y)=0)\\
                \perp & \text{se non esiste tale $y$}
            \end{cases}
        \end{aligned}$$
        \vspace{.7em}

        \begin{minipage}{.52\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
        \begin{algorithm}[H]
            \setstretch{1.2}
            \SetKwSty{texttt}
            \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
            \tcp{$x_1\leftarrow\sottolinea{x}$}
            \begin{}{
                $y:=0$\tcp*{parto da 0}
                {\SetAlgoNoEnd
                \While{$F(\sottolinea{x},y)\neq 0$}{
                    $y:=y+1$\tcp*{salgo di 1}
                }}
            }
        \end{algorithm}
        \end{tcolorbox}
        \end{minipage}\hfill
        \begin{minipage}{.37\textwidth}
            L'idea del programma è partire dal valore più basso che $y$ può assumere
            in $\N$, ovvero 0, per poi salire di un'unita fino a trovare il primo valore 
            che azzera $f(\sottolinea{x},y)$; se il valore non esiste o $F(\sottolinea{x},y)$
            va in loop prima di trovarlo si avrà un loop che produce $\perp$ in output.
        \end{minipage}
    \end{enumerate} 
\end{proof}
Il precedente teorema permette di dire che qualsiasi funzione ricorsiva parziale può essere
calcolata da un programma WHILE. Si vedrà ora che per qualsiasi programma WHILE esiste una
funzione ricorsiva parziale che è uguale alla semantica del programma 
($F(\text{WHILE}) \subseteq \ricPar$).

\begin{theorem}
    $F(\text{WHILE}) \subseteq \ricPar$
\end{theorem}
\begin{proof}
    Se $F(\text{WHILE}) \subseteq \ricPar$ allora:
    $$ \semWHILE_W\in F(\text{WHILE})\ \Rightarrow\ \semWHILE_W
    \in\ricPar = \elem^{\comp,\RP,\MIN}$$
    Si dovrà quindi dimostrare che per un qualsiasi programma $W$, la sua semantica
    $\semWHILE_W$ apparterrà a $\ricPar$ e potrà essere espressa come
    composizione, ricorsione primitiva e minimalizzazione a partire da funzioni di
    $\elem$.

    $$ \semWHILE_W(x) = \Pro_0^{21}(\opsemWHILE{W}{W\text{-in}(x)}) $$
    \begin{itemize}
        \item La funzione \opsemWHILE{C}{\sottolinea{x}} restituisce un array di 21
            elementi che rappresenta lo stato prossimo della macchina WHILE applicando
            il comando $C$ allo stato attuale $\sottolinea{x}$;
        \item La funzione $W\text{-in}(n)$ restituisce lo stato iniziale della
            macchina WHILE su input $n$;
        \item $\Pro_0^{21}$ preleva l'output dal registro $x_0$.
    \end{itemize}
    $\semWHILE_W$ è la composizione di $\Pro_0^{21}\in\elem$ con la funzione
    stato prossimo $\opsemWHILE{W}{W\text{-in}(x)}$. Si ha quindi che:

    \begin{minipage}{.5\textwidth}
    \begin{enumerate}
        \item $\Pro_0^{21}\in\elem \ \Rightarrow \ \Pro_0^{21}\in\ricPar$
        \item $\ricPar$ è chiuso rispetto alla composizione
    \end{enumerate}
    \end{minipage}
    \begin{minipage}{.4\textwidth}
        $\Rightarrow \quad \opsemWHILE{C}{\sottolinea{x}}\in\ricPar \ \Rightarrow \ 
        \semWHILE_W\in\ricPar$
    \end{minipage}

    Se quindi si dimostra che $\opsemWHILE{C}{\sottolinea{x}}\in\ricPar$ allora anche
    la sua semantica $\semWHILE_W$ sarà una funzione ricorsiva parziale.

    La funzione $\opsemWHILE{}{}:\N^{21}\to\N^{21}$ ha come codominio $\N^{21}$ mentre
    $\ricPar$ contiene funzioni che lavorano in $\N$: per risolvere questo problema
    si definisca una nuova funzione $f_C$ in cui viene applicato Cantor sull'array 
    degli stati:
    $$ \opsemWHILE{C}{\sottolinea{x}} = \sottolinea{y} \quad \text{con }
     \ \ \sottolinea{x},\sottolinea{y}\in\N^{21}$$
    $$ f_C(x)=y \quad \text{con }
     \ \ x=[\sottolinea{x}]\ ,\ y=[\sottolinea{y}]$$
    
    Si noti che per passare da $\opsemWHILE{C}{\sottolinea{x}}$ a $f_C(x)$ 
    si usano operazioni ricorsive parziali:
    $$\begin{aligned}
        f_C(x)&=y\\
        {\color{red}\Pro\in\ricPar}\quad &
        \mathlarger{{\color{red}\downarrow}{\color{blue}\uparrow}}
        \quad\color{blue}[\ ]\in\ricPar\\
        \opsemWHILE{C}{\Pro(0,x),\dots,\Pro(20,x)}&=(\Pro(0,y),\dots,\Pro(20,y))
    \end{aligned}$$
    Quindi si ha che $f_C$ si comporta come $\opsemWHILE{C}{\sottolinea{x}}$ sullo 
    stato prossimo. Basterà ora dimostrare che $f_C$ effettivamente è una funzione
    ricorsiva parziale:
    $$ f_C\in\ricPar \ \ \Leftrightarrow \ \ \opsemWHILE{C}{\sottolinea{x}}\in\ricPar$$

    Vista la definizione induttiva di $\opsemWHILE{}{}$ si usi l'induzione
    strutturale:
    \begin{itemize}
        \item BASE:
            \begin{itemize}
                \renewcommand{\labelitemii}{\raisebox{5.2\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{x_k:=0} \\[.6em]
                    &\hspace{2em}f_C(x) = {\color{red}[}
                    {\color{red}\Pro}(0,x),\dots,{\color{red}0},\dots,{\color{red}\Pro}
                    (20,x){\color{red}]}\\
                    &\hspace{10.05em}\overset{\uparrow}{\text{posizione $k$}}\\
                    & \text{Viene usata una composizione di {\color{red}funzioni 
                        $\in\ricPar$}}
                        \ \Rightarrow \ f_{x_k:=0}\in\ricPar
                \end{aligned}$
                \renewcommand{\labelitemii}{\raisebox{5.2\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{x_k:=x_j+/\dotminus 1}\\[.6em]
                    &\hspace{2em}f_C(x) = {\color{red}[}
                    {\color{red}\Pro}(0,x),\dots,
                    {\color{red}\Pro}(j,x){\color{red}+/\dotminus 1}
                    ,\dots,{\color{red}\Pro}
                    (20,x){\color{red}]}\\
                    &\hspace{10.05em}\overset{\uparrow}{\text{posizione $k$}}\\
                    & \text{Viene usata una composizione di {\color{red}funzioni 
                        $\in\ricPar$}}
                        \ \Rightarrow \ f_{x_k:=x_j\pm1}\in\ricPar
                \end{aligned}$
            \end{itemize}
        \item PASSO:
            \begin{itemize}
                \renewcommand{\labelitemii}{\raisebox{2.1\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{
                        \textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend
                    }\\[.6em]
                    &\hspace{2em}f_C(x) = f_{C_m}(\dots f_{C_1}(x)\dots)\\
                \end{aligned}$
                \vspace{.7em}

                Viene usata una composizione di $f_{C_i}\in\ricPar$
                per ipotesi induttiva $\ \Rightarrow \ f_{C}\in\ricPar $

                \renewcommand{\labelitemii}{\raisebox{2.1\height}{$-$}}
                \item $\begin{aligned}
                    &C'\equiv \boxed{\while{x_k}{C}}\\[.6em]
                    &\hspace{2em}f_{C'}(x) = f_C^{e(x)}(x)
                    \ \ \text{ con } \ e(x)=\mu y(\Pro(k,f_c^y(x))=0)\\
                \end{aligned}$

                Sorge qui un problema: $e(x)$ non è costante; non basta quindi 
                la composizione in quanto può essere applicata solo su un numero 
                costante di funzioni.

                Si dovrà allora definire una funzione $T\in\ricPar$:
                $$T(x,y)=f_C^y(x)$$
                È facile farlo usando l'operatore di ricorsione primitiva $\RP$:
                $$ T(x,y) = \begin{cases}
                    x&y=0\\
                    f_C(T(x,y-1))&y>0
                \end{cases} $$
                Siccome:

                \begin{minipage}{.38\textwidth}
                \begin{enumerate}
                    \item $f_C\in\ricPar$ per ipotesi induttiva
                    \item $\RP\in\ricPar$
                \end{enumerate}
                \end{minipage}
                \begin{minipage}{.4\textwidth}
                    $\Rightarrow \ T(x,y)\in\ricPar$
                \end{minipage}
                
                $$ \begin{aligned}
                    e(x)&=\mu y(\Pro(k,f_c^y(x))=0)\\
                    &=\mu y(\Pro(k,T(x,y))=0)
                \end{aligned} $$
                $e(x)$ è una minimalizzazione di $T(x,y)\in\ricPar$, quindi 
                $e(x)\in\ricPar$

                Infine:
                $$ f_{C'}(x) = f_C^{e(x)}(x) = {\color{red}T}(x,{\color{red}e}(x)) $$
                $f_{C'}$ è formato da una composizione di funzioni $\in\ricPar$
                $\ \Rightarrow \ f_{C'}\in\ricPar$.
            \end{itemize}
    \end{itemize}
    Per induzione strutturale si conclude che $F(\text{WHILE}) \subseteq \ricPar$.
\end{proof}

Il precedente teorema unito al teorema \ref{th:ricParWhile} permettono di affermare che:
$$ F(\text{WHILE}) = \ricPar $$

\subsubsection{Funzioni ricorsive totali}
Il seguente schema mostra il quadro generale dell'idea intuitiva di calcolabilità:
\vspace{1em}
\begin{center}
    \input{figures/calcolabilita2.tex}
\end{center}

L'insieme $\ricPar$ delle funzioni ricorsive parziali contiene tutte le funzioni
calcolabili, incluse quelle parziali. Questo vuol dire che in $\ricPar$ ci sono anche
programmi che non garantiscono una risposta in quanto potrebbero andare il loop.

Per delinare tutte le funzioni totali calcolabili, ovvero che possono essere calcolate
da programmi che garantiscono una risposta, viene usato l'insieme delle funzioni
ricorsive totali $\ricTot$:
$$\ricTot = \{\text{funzioni ricorsive totali}\} $$
\vspace{.1em}
\begin{center}
    \input{figures/calcolabilita3.tex}
\end{center}
\vspace{.5em}

\subsubsection{Tesi di Church-Turing}
Numerosi studiosi, a partire dagli anni 30, hanno provato a formalizzare il concetto di
calcolabilità cercando quindi di definire quali siano le funzioni che possono essere
calcolate da un qualsiasi programma in un qualsiasi sistema di calcolo.

Per farlo, sono stati introdotti innumerovoli e variegati sistemi di calcolo e, per
ognuno di questi, è stato studiato che tipo di funzioni sono in grado di calcolare:
\textbf{in tutti i casi si è arrivati alla stessa conclusione, ovvero che i sistemi
di calcolo visti sono in gado di calcolare funzioni ricorsive primite.}

Da qui deriva la tesi di Church-Turing:
\begin{center}
    \begin{minipage}{.9\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
            Le classi delle funzioni intuitivamente calcolabili coincide con la classe 
            $\ricPar$ delle funzioni ricorsive parziali;
        \end{tcolorbox}
    \end{minipage}
\end{center}
Per intuitivamente calcolabile si intende calcolabile da un modello di calcolo
\quotes{ragionevole} come quelli mostrati nel corso degli ultimi cent'anni.

\textbf{È importante sottolineare che la tesi di Church-Turing è una congettura, 
un'opinione. Non c'è infatti nessuna evidenza che non possa esistere un sistema di 
calcolo in grado di calcolare funzioni $f\notin\ricPar$.}

\subsection{Assiomatizzazione dei sistemi di calcolo}
Si vuole ora cercare di individuare alcune proprietà \quotes{buone}, auspicabili da 
un sistema di calcolo, dette assiomi. Tutti i sistemi di programmazione che rispettano
questi assiomi si diranno sistemi di programmazione accettabili.

In questo moda si potranno dimostrare determinate proprietà non sul singolo sistema
ma su tutti i sistemi accettabili.

Per indicare un sistema di programmazione si userà la seguente notazione:
$$ \sistProg_{i\in\N} $$
dove $\semRAM_i$ è la funzione calcolata dal programma la cui codifica è 
$i\in\N$.

\subsubsection{Assiomi di Rogers}
Gli assiomi di Rogers vogliono essere quelle \quotes{buone} proprietà ricercate in
un sistema di programmazione; in particolare si afferma che: un sistema di
programmazione $\sistProg$ si dice \textbf{accettabile (o spa)} se: 
\begin{enumerate}
    \item Aderisce alla tesi di Church-Turing;
    \item Esiste un interprete universale;
    \item Rispetta il teorema $S_n^m$.
\end{enumerate}

Si vedranno ora nello specifico gli assiomi e si vedrà anche che il sistema RAM
li rispetta.

\subsubsection*{Primo assioma}
$\sistProg$ rispetta il primo assioma se rispetta la tesi di Church-Turing
ovvero:
$$ \sistProg =\ricPar $$

Il sistema RAM, come ampiamente dimostrato nelle sezioni precedenti, rispetta
il primo assioma:
$$ F(\RAM)=\ricPar $$

Si vogliono considerare i sistemi di calcolo ne troppo poco potenti (sotto $\ricPar$),
ne troppo potenti (oltre $\ricPar$).

\subsubsection*{Secondo assioma}
$\sistProg$ rispetta il secondo assioma se esiste un interpete universale ovvero:
$$ \exists\mu\in\N : \forall x,n\in\N: \semRAM_\mu(\cantor{x,n})=
\semRAM_n(x) $$

Vedi sezione \ref{sec:interpreteU} per il sistema RAM.

La presenza di un interprete universale permette di avere \quotes{un'algebra sui
programmi}.

\subsubsection*{Terzo assioma}
$\sistProg$ rispetta il terzo assioma se rispetta il teorema $S_n^m$.

Prima di mostrare il teorema $S_n^m$ si vedrà un teorema più specifico, quello
$S_1^1$.
\begin{theorem}[$S_1^1$]
    Dato $\sistProg$ $\RAM$, esiste una funzione $S_1^1\in\ricTot$ tale che:
    $$ \forall n,x,y\in\N \quad \semRAM_n(\cantor{x,y})
    = \semRAM_{S_1^1(n,y)}(x) $$
\end{theorem}
In altre parole è possibile costruire automaticamente programmi più specifici
da programmi più generali, ottenuti prefissando alcuni input.
\begin{proof}
In generale il programma $S_1^1$ implementa la funzione:
$$ S_1^1(n,y) = \bar{n} \ \text{ tale che } \ \semRAM_{\bar{n}}(x)
=\semRAM_n (x,y)$$
dove:
\begin{itemize}
    \item $n$ è la codifica del programma $P$ a due variabili di input $x,y$
    \item $\bar{n}$ è la codifica del programma $\bar{P}$ ad una variabile
        la cui semantica è identica a quella di $P$ a cui fisso a $y$ il
        secondo input
\end{itemize}

Analizzando il sistema RAM si prenda un programma $P$ a due variabili:

\vspace{-1em}
\begin{minipage}{.4\textwidth}
    \begin{align}
        P \equiv\ & \texttt{// input $\cantor{x,y}$ in $R_1$}   \notag\\
        & R_2 \leftarrow \sin(R_1)                     \notag\\
        & R_3 \leftarrow \dx(R_1)                      \notag\\
        & R_0 \leftarrow R_2+R_3                       \notag
    \end{align}
\end{minipage}
\begin{minipage}{.4\textwidth}
    $$ \semRAM_P(\cantor{x,y})=x+y $$
\end{minipage}

Si vuole produrre un programma $\bar{P}$ con un solo input $x$ che restituisca
$x+3$; tutto questo partendo dal programma $P$. Si fissa quindi la seconda variabile
di $P$ a 3. La funzione $S_1^1$ dovrà restituire $\bar{P}$:

\begin{minipage}{.46\textwidth}
    \begin{center}
        \input{figures/S11.tex}
    \end{center}
\end{minipage}
\begin{minipage}{.46\textwidth}
    \begin{tabular}{r l l}
        $\bar{P}\equiv$ & $\texttt{// input $x$ in $R_1$}$   &       \\
        & $R_0 \leftarrow R_0+1$ & 
            \multirow{3}{*}{\hspace{-2em}
                $\begin{rcases}
                    \phantom{}\\
                    \phantom{}\\
                    \phantom{}\\
                \end{rcases}$ fissa $y$ a 3
            }\\
        & $R_0 \leftarrow R_0+1$                               \\
        & $R_0 \leftarrow R_0+1$                               \\
        & $R_1 \leftarrow \cantor{R_1,R_0}$ & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ input di $P$\\
        & $R_0 \leftarrow 0$  & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ pulisci $R_0$\\
        & $R_0 \leftarrow R_2+R_3$ & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ richiama $P$                         
    \end{tabular}
\end{minipage}

Si consideri il programma $\bar{P}$ nel caso generale, fissando la seconda variabile
a un valore $y$:

\begin{center}
    \begin{tabular}{r l l c c}
        $\bar{P}\equiv$ & $\texttt{// input $x$ in $R_1$}$
            &&codifica  \\
        & $R_0 \leftarrow R_0+1$ &
            \multirow{3}{*}{\hspace{-2em}
                $\begin{rcases}
                    \phantom{}\\
                    \phantom{}\\
                    \phantom{}\\
                \end{rcases} y$ volte
            } & $\longmapsto$ & 0 \\
        & $\hspace{2.6em}\vdots$ & & $\vdots$   \\
        & $R_0 \leftarrow R_0+1$ & & $\longmapsto$ & 0  \\
        & $R_1 \leftarrow \cantor{R_1,R_0}$ & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ input di $P$ & $\longmapsto$ & s\\
        & $R_0 \leftarrow 0$  & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ pulisci $R_0$ & $\longmapsto$ & t\\
        & $R_0 \leftarrow R_2+R_3$ & 
        \hspace{-2em}
            $\begin{rcases}
                \phantom{}
            \end{rcases}$ richiama $P$ & $\longmapsto$ & n                
    \end{tabular}
\end{center}
La codifica del programma $\bar{P}$ è:
$$ cod(\bar{P}) = \bar{n} = \cantor{\underbrace{0,\dots,0}_{y\text{ volte}},s,t,n} $$
Si può quindi notare che $S_1^1$ è:

\begin{minipage}{.3\textwidth}
    \begin{enumerate}
        \item Una funzione totale;
        \item Programmabile.
    \end{enumerate}
\end{minipage}
\begin{minipage}{.25\textwidth}
    $$ \Rightarrow \quad S_1^1 \in \ricTot $$
\end{minipage}
\end{proof}
\vspace{1em}

\begin{theorem}[$S_n^m$]
    Dato $\sistProg$ $\RAM$, esiste una funzione $S_n^m\in\ricTot$ tale che:
    $$ \forall k\in\N,\sottolinea{x}\in\N^m,\sottolinea{y}\in\N^n 
    \quad \semRAM_k(\cantor{\sottolinea{x},\sottolinea{y}})
    = \semRAM_{S_n^m(k,\sottolinea{y})}(\cantor{\sottolinea{x}}) $$
\end{theorem}
Il teorema è una generalizzazione di $S_1^1$; $S_n^m$ tratta programmi a $m+n$
input in cui si prefissano $n$ input e se ne lasciano liberi $m$. Anche la
dimostrazione è una semplice generalizzazione di quella di $S_1^1$.

\subsubsection{Compilatori tra spa}
Dati due sistemi di programmazione accettabili (spa) $\sistProg$ e $\sistProgW$, un
compilatore dal primo al secondo spa è una funzione $t:\N\to\N$ che possiede le
seguenti proprietà:

\begin{minipage}{.66\textwidth}
\begin{enumerate}
    \setlength\itemsep{.4em}
    \item Correttezza: $\forall i\in\N \quad \semRAM_i=\semWHILE_{t(i)}$;
    \item Completezza: compila ogni programma $i\in\N$;
    \item Programmabilità: esiste un programma che implementa $t$.
\end{enumerate}    
\end{minipage}
\begin{minipage}{.25\textwidth}
    \vspace{1.1em}
    $\begin{rcases}
        \phantom{}\\\phantom{}\\
    \end{rcases} t\in\ricTot$
\end{minipage}\vspace{1em}

\begin{theorem}\label{theo:spa_comp}
    Dati due spa, esiste un compilatore tra essi.
\end{theorem}
\begin{proof}
    Si considerino due spa $\sistProg$ e $\sistProgW$. Essendo spa rispettano gli
    assiomi:
    \begin{enumerate}
        \item $\sistProg=\ricPar$
        \item $\exists u: \semRAM_u(\cantor{x,n})=
            \semRAM_n(x)$
        \item $\exists S_1^1\in\ricTot:\semRAM_n(\cantor{x,y})=
            \semRAM_{S_1^1(n,y)}(x)$
    \end{enumerate}

    \begin{equation}\label{eq:spa_comp}
        \semRAM_i(x)\overset{(2)}{=} 
        \semRAM_u(\cantor{x,i})\overset{(1)}{=}
        \semWHILE_e(\cantor{x,i})\overset{(3)}{=}
        \semWHILE_{S_1^1(e,i)}(x)
    \end{equation}
    \vspace{-.5em}

    \begin{enumerate}
        \item[(2)] Applicazione diretta dell'assioma 2;
        \item[(1)] Entrambi gli spa possono calcolare le funzioni in $\ricPar$
            (assioma 1): esiste in $\sistProgW$ un programma $e$ con la stessa semantica
            del programma $u$;
        \item[(3)] Tramite la funzione $S_1^1$ (assioma 3) ottengo il programma che fissa
            la seconda variabile del programma $e$ ad $i$.
    \end{enumerate}

    Si è quindi trovata la funzione $t(i)=S_1^1(e,i)$ valida per ogni $i\in\N$.
    $t$ è un compilatore poichè:
    \begin{enumerate}
        \item $t\in\ricTot$ in quanto $S_1^1\in\ricTot$(assioma 3);
        \item $T$ è corretto in quanto $\semRAM_i=\semWHILE_{t(i)}$
         (\ref{eq:spa_comp}).
    \end{enumerate}
\end{proof}
\begin{corollario}
    Dati gli spa $A,B,C$ esiste sempre un compilatore da $A$ a $B$ scritto
    in $C$. 
\end{corollario}
\begin{proof}\phantom{x}
    \begin{itemize}
        \item Per il teorema \ref{theo:spa_comp} esiste un compilatore $t\in\ricTot$
            tra $A$ e $B$;
        \item Per il primo assioma $C$ contiene tutte le funzioni ricorsive parziali
            tra cui è presente anche $t$ (in quanto $t\in\ricTot\subset\ricPar=C$)
    \end{itemize}
\end{proof}

\begin{theorem}[Isomorfismo tra spa (Rogers)]
    Dati due spa $\sistProg$ e $\sistProgW$, esiste un compilatore $t:\N\to\N$ tra
    i due sistemi tale che $t$ è invertibile ($t^{-1}$ è un decompilatore).
\end{theorem}

Si noti che la decompilazione di un programma non restituisce semplicemente un
programma con la stessa semantica, ma restituisce esattamente lo stesso programma
che è stato originariamente compilato.

\subsubsection{Teorema di ricorsione}
\begin{theorem}[Teorema di Ricorsione]\label{theo:ric}
    Dato un spa \sistProg, per ogni $t:\N\to\N$ ricorsiva totale vale:
    $$ \exists n\in\N:\semRAM_n=\semRAM_{t(n)} $$
\end{theorem}

A parole, sia $t$ un programma che trasforma programmi con lo scopo di cambiare
totalmente la semantica del programma (rompendolo su tutti gli input). Qualunque
sia la manipolazione effettuata da $t$, esisterà sempre un programma $n$ che non 
viene rotto dalla manipolazione di $t$.
\begin{proof} \phantom{x}

D'ora in avanti, per semplicità, si scriverà $\semRAM_i(x,y)$ al
posto di $\semRAM_i(\cantor{x,y})$.

Si applichino i (3) assiomi:
\begin{equation}\label{eq:ric_tot1}
\semRAM_{\semRAM_i(i)}(x) \overset{(2)}{=} 
\semRAM_{\semRAM_u(i,i)}(x) \overset{(2)}{=} 
\semRAM_{u}(x,\semRAM_u(i,i)) = f(x,i)
\end{equation}
$\semRAM_{u}(x,\semRAM_u(i,i))$ è la composizione di $\semRAM_u\in\ricPar$ con se
stesso al variare delle variabili $x$ e $i$. $f(x,i)$ è quindi ricorsiva parziale:
$$ f(x,i)\in\ricPar $$
\begin{equation}\label{eq:ric_tot2} 
f(x,i) \overset{(1)}{=}
\semRAM_e(x,i) \overset{(3)}{=}
\semRAM_{S_1^1(e,i)}(x)
\end{equation}
Si consideri una qualsiasi traduzione $t\in\ricTot$ e la si applichi a $S_1^1(e,i)$:
$$ t(S_1^1(e,i)) $$
$$ t\in\ricTot\ ,\ S_1^1\in\ricTot $$
$t(S_1^1(e,i))$ è ricorsiva totale e grazie al primo assioma si può dire che esiste
un programma $m$ che la calcola:
\begin{equation}\label{eq:ric_tot3}
    \exists m\in\N: \semRAM_m(i) = t(S_1^1(e,i))
\end{equation}
Sia:
$$ n = S_1^1(e,m) $$
\begin{equation}\label{eq:ric_tot4} 
    (\ref{eq:ric_tot1}),(\ref{eq:ric_tot2})\ \Rightarrow\ 
\semRAM_{\semRAM_i(i)}(x) = \semRAM_{S_1^1(e,i)}(x) \end{equation}
\vspace{.6em}
$$ \begin{aligned}
    \semRAM_n(x) = \semRAM_{S_1^1(e,m)}(x) \overset{(\ref{eq:ric_tot4})}{=}
    \semRAM_{\semRAM_m(m)}(x)\\
    \semRAM_{t(n)}(x) = \semRAM_{t(S_1^1(e,m))}(x) \overset{(\ref{eq:ric_tot3})}{=}
    \semRAM_{\semRAM_m(m)}(x)
\end{aligned}\quad \Rightarrow \quad \semRAM_n = \semRAM_{t(n)} $$
\end{proof}

\subsubsection*{Quine}
Dato un spa, esiste al suo interno un programma che restituisce se stesso (la
sua codifica)?
Formalmente:
$$ \exists j\in\N: \forall x\in\N \quad \semRAM_j(x)=j ?$$
Questi programmi sono dette \textbf{Quine}.

Si prenda RAM e il seguente programma:

\begin{center}
    \begin{tabular}{r l l}
        $P\equiv$ & $R_0 \leftarrow R_0+1$  & 
        \multirow{4}{*}{\hspace{-1em}
            $\begin{rcases}
                \phantom{}\\
                \phantom{}\\
                \phantom{\vdots}\\
                \phantom{}\\
            \end{rcases}$ $j$ volte $\ \Rightarrow \ cod(P)=
            \underbrace{\color{red}\cantor{0,0,\dots,0}}_{\text{$j$ volte}}
            = Z(j)$
        }\\
        & $R_0 \leftarrow R_0+1$  \\ 
        & \hspace{2em}$\vdots$    \\
        & $R_0 \leftarrow R_0+1$  \\                     
    \end{tabular}
\end{center}

Alla fine dell'esecuzione di $P$ si avrà $R_0=j$ a prescindere dall'input $x$:
\begin{equation}\label{eq:quine_1}
    \forall x\in\N \quad \semRAM_{Z(j)}(x) = j
\end{equation}
Si definisca la {\color{red}codifica del programma $P$} con $Z(j)$ che è uguale
alla codifica di Cantor di una lista di $j$ zeri in quanto l'unica istruzione usata
ha codifica 0 (vedi sezione \ref{sec:aritm_ram}). 
È evidente che per qualsiasi valore $j$, la funzione $Z(j)$ esiste ed è quindi totale;
inoltre è facilmente implementabile. Si può quindi dire che:
$$Z(j)\in\ricTot$$

Il teorema \ref{theo:ric} afferma che:
\begin{equation}\label{eq:quine_2}
    \exists j\in\N:\semRAM_j = \semRAM_{Z(j)}
\end{equation} 
Da (\ref{eq:quine_1}) e (\ref{eq:quine_2}) si ottiene che esiste un programma $j\in\N$
tale che:
$$ \semRAM_j(x) \overset{(\ref{eq:quine_2})}{=} \semRAM_{Z(j)}(x)
\overset{(\ref{eq:quine_1})}{=} j $$
$$\Downarrow$$
$$ \semRAM_j(x) = j $$

Quindi, sì,\textbf{ nel sistema RAM esiste una Quine. Questo vale anche in generale
per tutti gli spa che ammettono una codifica di programma.}

\subsubsection*{Compilatori completamente errati}
Dati due spa $\sistProg$ e $\sistProgW$, esiste un compilatore dal primo al secondo
completamente errato?

Con compilatore completamente errato si intende una funzione $t:\N\to\N$ tale che:
\begin{itemize}
    \item $t\in\ricTot$
    \item $\forall i\in\N \quad \semRAM_i\neq\semWHILE_{t(i)}$
\end{itemize}
ovvero un compilatore che sbaglia sempre.

Si consideri una qualunque traduzione $t\in\ricTot$:
\begin{center}
    Con i (3) assiomi si può dire che:  
\end{center}
$$
{\color{red}\semWHILE_{t(i)}(x)} \overset{(2)}{=}
\semWHILE_u(x,t(i)) \overset{(1)}{=}
\semRAM_e(x,t(i)) \overset{(3)}{=}
\semRAM_{S_1^1(e,t(i))}(x) = {\color{blue}\semRAM_{g(i)}(x)} $$
\begin{equation}\label{eq:comp_err1}
    {\color{red}\semWHILE_{t(i)}(x)} = 
    {\color{blue}\semRAM_{g(i)}(x)}
\end{equation} \vspace{.6em}
$$ g(i) = S_1^1(e,t(i))\qquad S_1^1,t\in\ricTot \ \Rightarrow \
{\color{OliveGreen}g\in\ricTot} $$
\begin{center}
    Si applichi il teorema di ricorsione:  
\end{center}
\begin{equation}\label{eq:comp_err2}
    {\color{OliveGreen}g\in\ricTot} \ \Rightarrow \ 
    \exists i\in\N:\semRAM_i=\semRAM_{g(i)} \end{equation}
%$$ (i) \text{ = viene usato l'assioma } i $$
\vspace{.6em}
$$ (\ref{eq:comp_err1}),(\ref{eq:comp_err2})\ \Rightarrow \ 
\exists i\in\N : \semRAM_i = \semWHILE_{t(i)}(x) $$
Quindi, no, \textbf{non può esistere un compilatore sempre errato}.

\subsection{Problemi di decisione}
Un problema di decisione è un problema che richiede una soluzione \quotes{booleana}:
o sì o no.
Formalmente, un problema si può definire come:

\begin{tabular}{|r l|l}\cline{1-2}
    \multicolumn{2}{|l|}{$\Pi$}&$\leftarrow$ nome del problema\\
    Istanza:& $x\in D$&$\leftarrow $ input del problema\\
    Domanda:& $p(x)?$&$\leftarrow \ p(x)$ è vera? \\ \cline{1-2}
\end{tabular}

\subsubsection{Decidibilità}
\begin{minipage}{.33\textwidth}
    \problema{$\Pi$}{$x\in D$}{$p(x)$}
\end{minipage}
\begin{minipage}{.65\textwidth}
    $\Pi$ è decidibile sse esiste un programma $P_\Pi$ che restituisce 1 se
    la proprietà $p$ è verificata su ogni input, o restituisce 0 se 
    la proprietà $p$ non è verificata su ogni input.
\end{minipage}
\vspace{1em}

Una formulazione più matematica del concetto di decidibilità parte dalla definizione
della \textbf{funzione soluzione} $\Phi$ associata al problema  $\Pi$:
$$ \fsol:D\to\{0,1\}\ \text{ tale che }\
\fsol(x) = \begin{cases}
    1 & p(x)\\
    0 & \lnot p(x)
\end{cases} $$

\textbf{$\Pi$ è decidibile sse $\fsol\in\ricTot$}.

Chiaramente, le due definizioni si equivalgono:
\begin{itemize}
    \item Il programma $P_\Pi$ calcola $\fsol$;
    \item Se $\fsol\in\ricTot$ allora esiste un programma che la calcola con la
        stessa semantica di $P_\Pi$.
\end{itemize}
\vspace{1em}

Dato il problema di decisione $\Pi$, posso dimostrare la sua decidibilità in due modi:
\begin{enumerate}
    \item O esibendo un algoritmo di soluzione;
    \item O mostrando che $\fsol$ è ricorsiva totale. 
\end{enumerate}

\subsubsection*{Esempi}

\begin{minipage}{.55\textwidth}
    \begin{flushright}
        \problema{PARITÀ (PR)}{$n\in\N$}{$n$ è pari}
    \end{flushright}
\end{minipage}
\begin{minipage}{.02\textwidth}\phantom{x}\end{minipage}
\begin{minipage}{.41\textwidth}
    \textbf{Funzione soluzione}\\[.5em]
    $\fsol[\text{PR}](n) = 1\dotminus(n\bmod{2})$\\[.5em]
    $ \fsol[\text{PR}]\in\ricTot\ \Rightarrow\ \text{PR decidibile} $
\end{minipage}

\begin{minipage}{.55\textwidth}
    \begin{flushright}
        \problema{EQ. DIOFANTEA (ED)}{$a,b,c\in\N^+$}{$\exists x,y\in\Z:ax+by=c$}
    \end{flushright}
\end{minipage}
\begin{minipage}{.02\textwidth}\phantom{x}\end{minipage}
\begin{minipage}{.41\textwidth}
    \textbf{Funzione soluzione}\\[.5em]
    $\fsol[\text{ED}](a,b,c) = 1\dotminus(c\bmod{mcd(a,b)})$\\[.5em]
    $ \fsol[\text{ED}]\in\ricTot\ \Rightarrow\ \text{ED decidibile} $
\end{minipage}

\begin{minipage}{.55\textwidth}
    \begin{flushright}
        \problema{FERMAT (FR)}{$n\in\N^+$}{$\exists x,y,z\in\N^+:x^n+y^n=z^n$}
    \end{flushright}
\end{minipage}
\begin{minipage}{.02\textwidth}\phantom{x}\end{minipage}
\begin{minipage}{.41\textwidth}
    \textbf{Funzione soluzione}\\[.5em]
    $\fsol[\text{FR}](n) = 1\dotminus(n\dotminus 2)$\hspace{1em}[A.Wiles 1994]\\[.5em]
    $ \fsol[\text{FR}]\in\ricTot\ \Rightarrow\ \text{FR decidibile} $
\end{minipage}

\begin{minipage}{.55\textwidth}
    \begin{flushright}
        \begin{tcolorbox}[
            colback=white,
            sharp corners,
            boxrule=.3mm,
            boxsep=0pt,
            left=6pt,
            hbox
        ]
            \begin{tabular}{r p{13em}}
                \multicolumn{2}{l}{RAGGIUNGIBILITÀ (RG)}\\
                Istanza:& Grafo $G=(\{1,\dots,n\},E)$\\
                Domanda:& $\exists$ un cammino dal nodo 1 al nodo $n$ ?
            \end{tabular}
        \end{tcolorbox}
    \end{flushright}
\end{minipage}
\begin{minipage}{.02\textwidth}\phantom{x}\end{minipage}
\begin{minipage}{.41\textwidth}
    \textbf{Algoritmi di decisione}\\[.5em]
    Si effettua una visita in ampiezza o profondità,
    si usano algoritmi per cammini minimi etc...
\end{minipage}

\subsubsection{Problema dell'arresto}
\begin{center}
    \problema
        {ARRESTO SUL PROGRAMMA $P$ ($\text{AR}_P$)}
        {$x\in\N$}
        {$\semRAM_P(x)\termina$}
\end{center}\vspace{1em}
Si noti che $\text{AR}_P$ è una classe di problemi in cui viene fissato $P$ e si chiede
se il programma $P$ termina oppure no.

La decidibilità di $\text{AR}_P$ dipende dal programma $P$; per alcuni programmi
si può trovare una risposta ed è quindi decidibile. Tuttavia esistono dei programmi
dove $\text{AR}_P$ è indecidibile.\vspace{1em}

\begin{minipage}{.48\textwidth}
    Si prenda il seguente programma $\hat{P}$:
    \centering
    \begin{align}
    \hat{P} \equiv\ & \text{input($x$)}       \notag\\
    & Z := U(x,x)                             \notag\\
    & \text{output($Z$)}                      \notag
    \end{align}
    Dove $U$ è l'interprete universale.
\end{minipage}
\begin{minipage}{.48\textwidth}\centering
    E si definisca il problema $\text{AR}_{\hat{P}}$:
    $${\color{red}\semRAM_{\hat{P}}(x)}=\semRAM_{U}(x,x)={\color{red}\semRAM_{x}(x)}$$
    \problema{$\text{AR}_{\hat{P}}$}{$x\in\N$}
    {{\color{red}$\semRAM_{\hat{P}}(x)=\semRAM_x(x)\termina$}}
\end{minipage}\vspace{1em}

\begin{theorem}[Indecibilità di $\text{AR}_{\hat{P}}$]\label{theo:arrestoP}
    $\text{AR}_{\hat{P}}$ è indecidibile.
\end{theorem}
\begin{proof}
    Si ipotizzi per assurdo che $\text{AR}_{\hat{P}}$ sia decidibile. Si avrebbe quindi
    una funzione soluzione ricorsiva totale:
    $$ \fsol[\text{AR}_{\hat{P}}](x) =
    \begin{cases}
        1 & {\color{red}\semRAM_{\hat{P}}(x)=\semRAM_x(x)}\termina\\
        0 & {\color{red}\semRAM_{\hat{P}}(x)=\semRAM_x(x)}\text{\textuparrow}
    \end{cases} $$
    Partendo da $\fsol[\text{AR}_{\hat{P}}](x)\in\ricTot$ posso creare la seguente
    funzione sempre ricorsiva totale:
    $$ f(x) = \begin{cases}
        0 & \fsol[\text{AR}_{\hat{P}}](x)=0\\
        \semRAM_x(x)+1 & \fsol[\text{AR}_{\hat{P}}](x)=1
    \end{cases} $$
    Che è uguale a:
    $$ f(x) = \begin{cases}
        0 & \semRAM_x(x)\text{\textuparrow}\\
        \semRAM_x(x)+1 & \semRAM_x(x)\termina
    \end{cases} $$
    Essendo $f\in\ricTot$ esiste un programma $\alpha$ che la calcola:
    $$ f(x) = \semRAM_\alpha(x) $$
    Si valuti $\semRAM_\alpha$ in $\alpha$:
    \begin{equation} \semRAM_\alpha(\alpha) = \begin{cases}
        0 & \semRAM_\alpha(\alpha)\text{\textuparrow}\\
        \semRAM_\alpha(\alpha)+1 & \semRAM_\alpha(\alpha)\termina
    \end{cases}\tag{{\color{blue}ASSURDO}}\end{equation}
    $\semRAM_\alpha(\alpha)$ non può esistere in quanto:
    \begin{enumerate}
        \item Nel primo caso ($\semRAM_\alpha(\alpha)\text{\textuparrow}$) se 
            {\color{blue} $\semRAM_\alpha(\alpha)$ non termina allora 
            $\semRAM_\alpha(\alpha)=0$};
        \item Nel secondo caso ($\semRAM_\alpha(\alpha)\termina$) se
            $\semRAM_\alpha(\alpha)$ termina si ha che 
            {\color{blue}$\semRAM_\alpha(\alpha)=\semRAM_\alpha(\alpha)+1$}.
    \end{enumerate}
\end{proof}
\subsubsection*{Il problema generale dell'arresto}
La versione più generale del problema dell'arresto è stato data da Turing nel 1936 ed è:
\begin{center}
    \problema
    {ARRESTO (AR)}
    {$x,y\in\N$}
    {$\semRAM_y(x)\termina$}
\end{center}
dove $x$ è il dato e $y$ il programma.
\begin{theorem}[Indecibilità di AR]
    AR è indecidibile.
\end{theorem}
\begin{proof}
    Si assuma, per assurdo, che AR sia decidibile; esiste quindi una funzione soluzione:
    $$ \fsol[\text{AR}](x,y) = \begin{cases}
        0 & \semRAM_y(x)\text{\textuparrow}\\
        1 & \semRAM_y(x)\termina
    \end{cases} $$

    Si valuti il caso in cui $x=y$:
    $$ \fsol[\text{AR}](x,x) = \begin{cases}
        0 & \semRAM_x(x)\text{\textuparrow}\\
        1 & \semRAM_x(x)\termina
    \end{cases} $$

    Si noti che $\fsol[\text{AR}](x,x)=\fsol[\text{AR}_{\hat{P}}](x,x)$; quindi nel caso
    $x=y$ il problema AR diventa uguale al problema $\text{AR}_{\hat{P}}$. L'assunzione
    iniziale della dimostrazione afferma che esiste un programma in grado di decidere
    $\text{AR}_{\hat{P}}$, cosa che il teorema \ref{theo:arrestoP} dimostra non essere vera.
    Si ha quindi l'assurdo.
\end{proof}

\subsection{Riconoscibilità automatica di insiemi}
L'insieme $A\subseteq\N$ è riconoscibile automaticamente se esiste un programma $P_A$
che classifica correttamente \textbf{ogni} elemento di $\N$ come appartenente o meno 
ad $A$;

$P_A(x)$ restituisce 1 se $x\in A$ mentre restituisce 0 se $x\notin A$. 

$P_A(x)$ è corretto e termina su ogni input.

\subsubsection*{Funzione caratteristica}
Preso un insieme $A\subseteq\N$, la sua funzione caratteristica $\X$ è la funzione 
$\X_A:\N\to\{0,1\}$ tale che;
$$ \X_A(x)=\begin{cases}
    1 & x\in A\\
    0 & x\notin A
\end{cases} $$

\subsubsection{Insiemi ricorsivi}
L'insieme $A\subseteq\N$ è un insieme ricorsivo sse esiste un programma $P_A$ che si
arresta su ogni input classificando correttamente gli elementi di $\N$ in base alla
loro appartenenza ad $A$.

Equivalentemente, $A$ è ricorsivo sse $\X_A\in\ricTot$.

Si dirà, con un abuso di notazione, che gli insiemi ricorsivi sono decidibili. Questo
perchè ad ogni insieme $A\subseteq\N$ si può associare il corrispondente problema
$\text{RIC}_A$ di riconoscimento, che punta a decidere se un elemento $x$ appartiene o
meno ad $A$. Essendo $A$ ricorsivo si ha che la funzione soluzione $\fsol[\text{RIC}_A]$
coincide con la funzione caratteristica $\X_A$ e quindi il problema $\text{RIC}_A$ è
decidibile.

Allo stesso modo, sempre con un abuso di notazione, si dice che un problema di decisione
decidibile è ricorsivo. Questo perchè ad ogni problema di decisione posso associare
l'insieme delle istanze a risposta positiva.

\subsubsection{Insiemi non ricorsivi}
Un esempio di insieme non ricorsivo è l'insieme $A$ delle variabili con le quali il 
programma $\hat{P}$ termina.

\begin{minipage}{.49\textwidth}
    \problema{$\text{AR}_{\hat{P}}$}{$x\in\N$}
    {$\semRAM_{\hat{P}}(x)=\semRAM_x(x)\termina$}
\end{minipage}
\begin{minipage}{.49\textwidth}
    $A = \{x\in\N: \semRAM_x(x)\termina \}$
\end{minipage}\vspace{.6em}

Se $A$ fosse ricorsivo, vorrebbe dire che esisterebbe un programma $P_A$ in grado di dire
se un elemento sta al suo interno o meno. $P_A$ però, renderebbe la risoluzione del 
problema dell'arresto $\text{AR}_{\hat{P}}$ immediata, in quanto per decidere se, data
una variabile $x$, il programma $\hat{P}$ termina, basterebbe verificare tramite $P_A$ che
$x$ stia o meno in $A$. Tutto questo però è impossibile (teorema \ref{theo:arrestoP}).

\subsubsection{Relazioni ricorsive}
$R\subseteq\N\times\N$ è una relazione ricorsiva sse $R$ è ricorsivo ovvero
$\X_R\in\ricTot$; equivalentemente $R$ è una relazione ricorsiva se esiste
un programma $P_R$ che, presi due valori $x,y\in\N$, restituisce 1 se $x\ R\ y$, o
0 se $x\ \cancel{R}\ y$.

Un'importante relazione ricorsiva è:
$$ R_P = \{(x,y)\in\N^2:\text{$P$ su input $x$ termina in $y$ passi}\} $$
Si può facilmente costruire un programma che implementa $R_P$ aggiungendo una variabile
che conta i passi e, nel momento in cui supera gli $y$ passi restituisce 0, altrimenti se
termina prima restituisce 1.

\subsubsection{Insiemi ricorsivamente numerabili}
$A\subset\N$ è ricorsivamente numerabile se è automaticamente listabile, ovvero esiste
una routine $F$ che su input $i\in\N$ restituisce l'$i$-esimo elemento di $A$.

\vspace{1em}
\hspace{2em}
\begin{minipage}{.32\textwidth}
    \begin{tcolorbox}[
        colback=white,
        sharp corners,
        boxrule=.3mm,
        left=20pt
    ]
    \begin{algorithm}[H]
        \setstretch{1.2}
        \SetArgSty{relax}
        \SetAlgoNoEnd
        \SetKwSty{texttt}
        $i:=0$\;
        \While{True}{
            output($F(i)$)\;
            $i:=i+1$\;
        }
    \end{algorithm}
    \end{tcolorbox}
\end{minipage}
\hspace{2em}
\begin{minipage}{.49\textwidth}
    Per alcuni insiemi è il meglio che si può ottenere, non si riesce a riconoscere
    esattamente l'insieme ma si riesce a listarlo fino a un certo punto.
\end{minipage}\vspace{1em}

A questo punto si può scrivere un algoritmo che \quotes{tenta} di riconoscere $A$:
\vspace{1em}

\hspace{2em}
\begin{minipage}{.32\textwidth}
    \begin{tcolorbox}[
        colback=white,
        sharp corners,
        boxrule=.3mm,
        boxsep=0pt,
        left=20pt
    ]
    \begin{algorithm}[H]
        \setstretch{1.2}
        \SetArgSty{relax}
        \SetAlgoNoEnd
        \SetKwSty{texttt}
        input($x$)\;
        $i:=0$\;
        \While{$F(i)\neq x$}{
            $i:=i+1$\;
        }
        output(1)\;
    \end{algorithm}
    \end{tcolorbox}
\end{minipage}
\hspace{2em}
\begin{minipage}{.49\textwidth}
    Per alcuni insiemi è il meglio che si può ottenere, non si riesce a riconoscere
    esattamente l'insieme ma si riesce a listarlo fino a un certo punto. Preso in
    input $x$, il programma restituisce 1 se $x\in A$ o va in loop se $x\notin A$.
\end{minipage}\vspace{1em}

L'insieme $A\subset\N$ è ricorsivamente numerabile sse:
\begin{itemize}
    \item $A=\cancel{O}$
    \item $A=\text{Im}_f$ con $f:\N\to\N\in\ricTot$ \hspace{6em} $(A=\{f(0),f(1),\dots\})$ 
\end{itemize}\vspace{1em}

\begin{theorem}
    Le seguenti definizioni sono equivalenti:
    \begin{enumerate}
        \item $A$ è ricorsivamente numerabile ($A=\text{Im}_{f\in\ricTot}$)
        \item $A=\text{Dom}_f$ con $f\in\ricPar$
        \item Esiste una relazione $R\subseteq\N^2$ ricorsiva tale che:
            $$ A=\{ x\in\N\ |\ \exists y\in\N : (x,y)\in R \} $$ 
    \end{enumerate}
\end{theorem}
\begin{proof}
    Si dimostrerà che $(1)\Rightarrow(2)\Rightarrow(3)\Rightarrow(1)$.
    \begin{itemize}
        \item $(1)\Rightarrow(2)$
        \begin{itemize}
            \item[] Si consideri l'algoritmo di riconoscimento parziale di $A$:
            
            \begin{minipage}{.32\textwidth}
                \begin{tcolorbox}[
                    colback=white,
                    sharp corners,
                    boxrule=.3mm,
                    left=20pt,
                    top=0pt,
                    bottom=0pt,
                    title=$P$,
                    colbacktitle=white,
                    coltitle=black
                ]
                \begin{algorithm}[H]
                    \setstretch{1.2}
                    \SetArgSty{relax}
                    \SetAlgoNoEnd
                    \SetKwSty{texttt}
                    input($x$)\;
                    $i:=0$\;
                    \While{$F(i)\neq x$}{
                        $i:=i+1$\;
                    }
                    output(1)\;
                \end{algorithm}
                \end{tcolorbox}
            \end{minipage}\hspace{1em}
            \begin{minipage}{.50\textwidth}
                $$ \semRAM_P(x) = \begin{cases}
                    1 & x\in A\\
                    \perp & x\notin A
                \end{cases}\ \Rightarrow \ A=\text{Dom}_{\semRAM_P} $$
                Siccome $\semRAM_P$ viene calcolato da $P$ è ricorsiva parziale.
            \end{minipage}\vspace{1em}
        \end{itemize}
        \item $(2)\Rightarrow(3)$
        \begin{itemize}
            \item[] $A=\text{Dom}_{f\in\ricPar}\ \Rightarrow \ \exists R\subseteq\N^2
            \text{ ricorsiva tale che: }A=\{ x\ |\ \exists y:(x,y)\in R\}$

            Se $f\in\ricPar$ allora esiste un programma $P$ tale che $f=\semRAM_P$.
            $$ R_P = \{(x,y)\in\N^2:\text{$P$ su input $x$ termina in $y$ passi}\} $$
            Si definisca il seguente insieme:
            $$ B=\{ x\ |\ \exists y:(x,y)\in R_p \} $$
            \begin{itemize}
                \item[\textminus] $A\subseteq B$:
                    se $x\in A=\text{Dom}_{\semRAM_P}$ allora $P$ termina in $y$ passi,
                    quindi $(x,y)\in R_P$ e quindi $x\in B$.
                \item[\textminus] $B\subseteq A$: se $x\in B$ allora il programma $P$
                    su input $x$ termina in un numero finito di passi e quindi
                    $ x\in\text{Dom}_{\semRAM_P} \ \Rightarrow \ x\in A$
            \end{itemize}
            Quindi $A=B=\{ x\ |\ \exists y:(x,y)\in R_p \}$ con $R_P$ relazione ricorsiva.
        \end{itemize}
        \item $(3)\Rightarrow(1)$
            \begin{itemize}
                \item[] $A=\{ x\ |\ \exists y:(x,y)\in R\}\text{ con $r$ ricorsivo}
                \ \Rightarrow \ A=\text{Im}_{f\in\ricTot}$

                Sia $a\in A$ con $A\neq\cancel{O}$ e sia $t:\N\to\N$:
                $$ t(n) = \begin{cases}
                    \sx(n) & (\sx(n),\dx(n))\in R\\
                    a & \text{altrimenti}
                \end{cases} $$
                Poichè $R$ ricorsiva esiste un programma $P_R$ che la implementa:

                \begin{minipage}{.32\textwidth}
                    \begin{tcolorbox}[
                        colback=white,
                        sharp corners,
                        boxrule=.3mm,
                        left=20pt,
                        top=0pt,
                        bottom=0pt
                    ]
                    \begin{algorithm}[H]
                        \setstretch{1.2}
                        \SetArgSty{relax}
                        \SetAlgoNoEnd
                        \SetKwProg{if}{if}{}{}
                        \SetKwProg{els}{else}{}{}
                        \SetKwSty{texttt}
                        input($n$)\;
                        $x:=\sx(n)$\;
                        $y:=\dx(n)$\;
                        \if{$P_R(x,y)=1$}{
                            output(x)\;
                        }
                        \els{}{
                            output($a$)\;
                        }
                    \end{algorithm}
                    \end{tcolorbox}
                \end{minipage}\hspace{1em}
                \begin{minipage}{.50\textwidth}
                    \begin{itemize}
                        \setlength\itemsep{1em}
                        \item[\textminus] $A\subseteq\text{Im}_t$: $x\in A \
                        \Rightarrow \ (x,y)\in R\ \Rightarrow \ t(\cantor{x,y})=x\ 
                        \Rightarrow \ x\in\text{Im}_t$
                        \item[\textminus] $\text{Im}_t\subseteq A$:
                        \begin{itemize}\setlength\itemsep{.4em}
                            \item $x\in \text{Im}_t \ \Rightarrow \ x=a\in A$
                            \item $x=\sx(n)\text{ con }n=\cantor{x,y}$\\
                                $\text{ per qualche $y$ tale che }(x,y)\in R
                                \ \Rightarrow\ x\in A$
                        \end{itemize}
                    \end{itemize}
                \end{minipage}\vspace{1em}
            \end{itemize}
            Quindi $A=\text{Im}_t$ con $t\in\ricTot$.
    \end{itemize}
\end{proof}
\subsubsection{Confronto tra insiemi}
\begin{minipage}{.4\textwidth}
    \problema{$\text{AR}_{\hat{P}}$}{$x\in\N$}
    {$\semRAM_{\hat{P}}(x)=\semRAM_x(x)\termina$}
\end{minipage}
\begin{minipage}{.49\textwidth}
    $\ \Rightarrow\ A = \{x: \semRAM_x(x)\termina \}$
\end{minipage}\vspace{.6em}

$A$ non è ricorsivo ma è ricorsivamente numerabile:

\vspace{1em}\hspace{5em}
\begin{minipage}{.24\textwidth}
    \begin{tcolorbox}[
        colback=white,
        sharp corners,
        boxrule=.3mm,
        left=20pt,
        top=0pt,
        bottom=0pt,
        title=$P$,
        colbacktitle=white,
        coltitle=black
    ]
    \begin{algorithm}[H]
        \setstretch{1.2}
        \SetArgSty{relax}
        \SetAlgoNoEnd
        \SetKwSty{texttt}
        input($x$)\;
        $U(x,x)$\;
        output(1)\;
    \end{algorithm}
    \end{tcolorbox}
\end{minipage}
\begin{minipage}{.49\textwidth}
    \hspace{3em}$\semRAM_P(x)=\begin{cases}
        1 & \semRAM_x(x)\termina \hspace{23pt}  x\in A \\
        0 & \text{altrimenti}  \quad x\notin A
    \end{cases}$
\end{minipage}\vspace{.6em}

Infatti $A=\text{Dom}_{\semRAM_P}$ con $\semRAM_P\in\ricPar$.
\vspace{1.5em}

\begin{theorem}
    $A\subseteq\N$ ricorsivo$\ \Rightarrow \ A$ ricorsivamente numerabile.
\end{theorem}
\begin{proof}
    $A$ ricorsivo $\ \Rightarrow \ $ esiste un programma $P_A$ che classifica ogni elemento
    di $A$.
    \hspace{1em}

    \begin{minipage}{.31\textwidth}
        \begin{tcolorbox}[
            colback=white,
            sharp corners,
            boxrule=.3mm,
            left=20pt,
            top=0pt,
            bottom=0pt,
            title=$P$,
            colbacktitle=white,
            coltitle=black
        ]
        \begin{algorithm}[H]
            \setstretch{1.2}
            \SetArgSty{relax}
            \SetAlgoNoEnd
            \SetKwProg{if}{if}{}{}
            \SetKwProg{els}{else}{}{}
            \SetKwSty{texttt}
            input($x$)\;
            \if{$P_A(x)=1$}{
                output(1)\;
            } \els{}{
                \texttt{while}($1>0$)\;
            }
        \end{algorithm}
        \end{tcolorbox}
    \end{minipage}
    \begin{minipage}{.49\textwidth}
        \hspace{3em}$\semRAM_P(x)=\begin{cases}
            1 & x\in A \\
            \perp & x\notin A
        \end{cases}\ \Rightarrow \ A=\text{Dom}_{\semRAM_P}$
    \end{minipage}\vspace{.6em}
\end{proof}

\begin{theorem}[Chiusura degli insiemi ricorsivi]\label{theo:Arr_ric}
    La classe degli insiemi ricorsivi è un'Algebra di Boole; è quindi chiusa per
    complemento, intersezione e unione.
\end{theorem}
\begin{proof}
    Siano $A,B$ ricorsivi; esistono quindi due programmi $P_A$ e $P_B$ che li riconoscono.
    Si vedrà l'esistenza di programmi per riconoscere:
    \begin{itemize}
        \item $A^c$:  \hspace{1em}    
            \begin{minipage}{.35\textwidth}
            \begin{tcolorbox}[
                colback=white,
                sharp corners,
                boxrule=.3mm,
                left=20pt,
                top=0pt,
                bottom=0pt
            ]
            \begin{algorithm}[H]
                \setstretch{1.2}
                \SetKwSty{texttt}
                input($x$)\;
                output($1\dotminus P_A(x)$)\;
            \end{algorithm}
            \end{tcolorbox}
            \end{minipage}
        \item $A\cap B$:  \hspace{1em}    
            \begin{minipage}{.435\textwidth}
            \begin{tcolorbox}[
                colback=white,
                sharp corners,
                boxrule=.3mm,
                left=20pt,
                top=0pt,
                bottom=0pt
            ]
            \begin{algorithm}[H]
                \setstretch{1.2}
                \SetKwSty{texttt}
                input($x$)\;
                output($\min{\{P_A(x),P_B(x)\}}$)\;
            \end{algorithm}
            \end{tcolorbox}
            \end{minipage}
        \item $A\cup B$:  \hspace{1em}    
            \begin{minipage}{.435\textwidth}
            \begin{tcolorbox}[
                colback=white,
                sharp corners,
                boxrule=.3mm,
                left=20pt,
                top=0pt,
                bottom=0pt
            ]
            \begin{algorithm}[H]
                \setstretch{1.2}
                \SetKwSty{texttt}
                input($x$)\;
                output($\max{\{P_A(x),P_B(x)\}}$)\;
            \end{algorithm}
            \end{tcolorbox}
            \end{minipage}
    \end{itemize}
\end{proof}

\begin{theorem}
    $A^c=\{x:\semRAM_x(x)\textup{\ntermina}\}$ non è ricorsivo.
\end{theorem}
\begin{proof}
    Se $A^c$ fosse ricorsivo, per il teorema \ref{theo:Arr_ric} anche il suo complemento $A$ 
    sarebbe ricorsivo, il che è assurdo.
\end{proof}

\begin{theorem}
    $A$ ric. numerabile $\wedge\ A^c$ ric. numerabile $\ \Rightarrow\ A$ ricorsivo. 
\end{theorem}
\begin{proof}
    Se sia $A$ che $A^c$ sono ric. numerabili vuol dire che entrambi hanno un programma che
    è in grado di listarli. Si crei un programma che chiama, alternandoli, i due programmi,
    listando un pò per volta sia $A$ che $A^c$. Sia se $x\in A$ che $x\notin A$ il programma
    termina. 
\end{proof}

\begin{theorem}
    La classe degli insiemi ricorsivamente numerabili è chiusa per unione e intersezione
    ma non per il complemento.
\end{theorem}
\begin{proof}\phantom{x}
    \begin{itemize}
        \item Complemento: $A=\{x:\semRAM_x(x)\termina \}$ è ricorsivamente numerabile mentre
            $A^c$ non lo è;
        \item Intersezione: siano $F$ e $G$ le funzioni in grado di listare i due insiemi
            ric. numer. $A$ e $B$:

            \begin{minipage}{.29\textwidth}
                \begin{tcolorbox}[
                    colback=white,
                    sharp corners,
                    boxrule=.3mm,
                    left=20pt,
                    top=0pt,
                    bottom=0pt,
                    title=$P'$,
                    colbacktitle=white,
                    coltitle=black
                ]
                \begin{algorithm}[H]
                    \setstretch{1.2}
                    \SetKwSty{texttt}
                    \SetKwProg{while}{while}{}{}
                    input($x$)\;
                    $i:=0$\;
                    \while{$F(i)\neq x$}{$i:=i+1$\;}
                    \while{$G(i)\neq x$}{$i:=i+1$\;}
                    output(1)\;
                \end{algorithm}
                \end{tcolorbox}
            \end{minipage}
            \begin{minipage}{.4\textwidth}
                $$ \semRAM_{P'}(x) = \begin{cases}
                    1 & x\in A\cap B\\
                    \perp & \text{altrimenti}
                \end{cases} $$
                $$\text{Dom}_{\semRAM_{P'}} = A\cap B $$
                $$ \semRAM_{P'} \in \ricPar $$
            \end{minipage}\vspace{.6em}
        \item Unione: siano $F$ e $G$ le funzioni in grado di listare i due insiemi
            ric. numer. $A$ e $B$:
            
            \vspace{.6em}
            \begin{minipage}{.31\textwidth}
                \begin{tcolorbox}[
                    colback=white,
                    sharp corners,
                    boxrule=.3mm,
                    left=20pt,
                    top=0pt,
                    bottom=0pt,
                    title=$P''$,
                    colbacktitle=white,
                    coltitle=black
                ]
                \begin{algorithm}[H]
                    \setstretch{1.2}
                    \SetKwSty{texttt}
                    \SetKwProg{if}{if}{}{}
                    \SetKwProg{while}{while}{}{}
                    input($x$)\;
                    $i:=0$\;
                    \while{True}{
                        \if{$F(i)=x$}{output(1)\;}
                        \if{$G(i)=x$}{output(1)\;}
                        $i:=i+1$\;
                    }
                \end{algorithm}
                \end{tcolorbox}
            \end{minipage}
            \begin{minipage}{.4\textwidth}
                $$ \semRAM_{P''}(x) = \begin{cases}
                    1 & x\in A\cup B\\
                    \perp & \text{altrimenti}
                \end{cases} $$
                $$\text{Dom}_{\semRAM_{P''}} = A\cap B $$
                $$ \semRAM_{P''} \in \ricPar $$
            \end{minipage}
    \end{itemize}
\end{proof}

\subsubsection*{Situazione insiemistica}
\begin{minipage}{.6\textwidth}
    \begin{center}
        \input{figures/situazione_ins.tex}
    \end{center}
\end{minipage}
\begin{minipage}{.35\textwidth}
    \begin{itemize}
        \setlength\itemsep{1.4em}
        \item $A = \{x:\semRAM_x(x)\termina \}$
        \item $A^c = \{x:\semRAM_x(x)\ntermina \}$
    \end{itemize}
\end{minipage}

\subsubsection*{Teorema di Rice}

L'insieme $I\subseteq\N$ rispetta le funzioni sse $(a\in I\ \wedge\ \semRAM_a=\semRAM_b)
\ \Rightarrow \ b\in I$\vspace{1.5em}

\begin{theorem}[Teorema di Rice]
    Sia $I\subseteq\N$ un insieme che rispetta le funzioni. Allora $I$ è ricorsivo solo se
    $I=\cancel{O}$ oppure $I=\N$.
\end{theorem}
\begin{proof}
    Sia $I$ un insieme che rispetta le funzioni con $I\neq\cancel{O}$ e $I\neq\N$.
    Per assurdo, si ipotizzi $I$ ricorsivo e che rispetta le funzioni. 

    Si definisca la funzione $t:\N\to\N$ come:
    $$ t(x) = \begin{cases}
        \bar{a} & n\in I\\
        a & n\notin I
    \end{cases} \qquad\qquad t\in\ricTot $$
    dove $a\in I$ e $\bar{a}\notin I$.

    Essendo $t\in\ricTot$ il teorema di ricorsione (\ref{theo:ric}) garantisce per gli spa
    l'esistenza di un valore $d\in\N$:
    $$ \semRAM_d(x) = \semRAM_{t(d)} $$
    Si prenda $d$:
    \begin{itemize}
        \item $d\in I$: poichè $I$ rispetta le funzioni e $\semRAM_d=\semRAM_{t(d)}$ allora
            deve valere che $t(d)\in I$. Ma $t(d)=\bar{a}\notin I\ \Rightarrow \ $
            contraddizione. 
        \item $d\notin I$: $t(d)=a\in I$ e poichè $I$ rispetta le funzioni e 
            $\semRAM_d=\semRAM_{t(d)}$ si ha $d=t(d)=a\in I\ \Rightarrow \ $
            contraddizione. 
    \end{itemize}
\end{proof}

Il teorema di Rice è uno strumento molto utile per mostrare che un insieme $a\in\N$ non
è ricorsivo; per verificarlo si può infatti:

\begin{minipage}{.45\textwidth}
    \begin{enumerate}
        \setlength\itemsep{.6em}
        \item Mostrare che $A$ rispetta le funzioni;
        \item Mostrare che $A\neq\cancel{O}$ e $A\neq\N$
    \end{enumerate}
\end{minipage}
\begin{minipage}{.4\textwidth}
    $ \overset{\text{Rice}}{\ \Longrightarrow} \ \text{$A$ non è ricorsivo} $
\end{minipage}

\subsubsection*{Verifica automatica de correttezza del software}
\begin{description}[leftmargin=1.9cm]
    \item[Problema:] si può scrivere un programma $V$ che testa automaticamente se un programma
    sia corretto o meno?
\end{description}

Sia $PC$ l'insieme dei programmi corretti: $$ PC = \{P\in\N:\text{$P$ è corretto}\} $$
$PC$ può essere riconosciuto da $V$? $PC$ è ricorsivo?

\begin{itemize}
    \item $PC$ \textbf{rispetta le funzioni} in quanto:
    $$P\in PC \ \wedge\ \semRAM_P=\semRAM_{P'} \ \Rightarrow\ P'\in PC$$
    Se il programma $P$ è corretto e la semantica del programma $P'$ è la stessa di $P$, 
    allora anche $P'$ è corretto.
    \item $PC\neq\cancel{O}\ \wedge\ PC\neq\N$: sarebbe insensato avere delle specifiche con le
    quali nessun programma è corretto o delle specifiche dove tutti i programmi sono corretti.
\end{itemize}

Per il teorema di Rice si può affermare che $PC$ non è ricorsivo. Non esiste quindi un
programma $V$ che lo identifica correttamente.