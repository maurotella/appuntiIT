\section{Teoria della calcolabilità}

\subsection{Sistema di calcolo \texorpdfstring{$\SC$}{C}}
Si vuole modellare matematicamente un calcolatore o sistema di calcolo $\SC$:
\vspace{.4cm}
\begin{figure}[h]
    \centering
    \input{figures/sistema_calcolo.tex}
\end{figure}

La figura mostra il sistema di calcolo $\SC$ che, preso un programma $P$
su input $x$, restituisce in output il risultato $y$ o il valore $\perp$
se il programma va in loop.

DATI è l'insieme di tutti i possibili dati di input e PROG l'insieme di
tutti i possibili programmi.

Il sistema di calcolo $\SC$ non fa altro che eseguire il programma $P$ su input
$x$ ricavandone il risultato $y$:
\begin{equation}\label{eq:sistema_calcolo}
\SC:\text{PROG}\times\text{DATI}\rightarrow\text{DATI}_\perp
\end{equation}

Quello che fa il programma $P$ è trasformare il dato di input $x$ in un dato
di output $y$; si può quindi dire che un programma non è altro che
una funzione che agisce da DATI in DATI:
$$ P:\text{DATI} \rightarrow \text{DATI}_\perp $$
$$ \Downarrow $$
\begin{equation}\label{eq:prog_dati} \text{PROG} =
\text{DATI}^{\text{DATI}}_\perp \end{equation}

La funzione associata al programma $P$ è detta \textbf{semantica di $P$}.

Da (\ref{eq:sistema_calcolo}) e (\ref{eq:prog_dati}) si ottiene che:
$$ \SC:\text{DATI}^{\text{DATI}}_\perp\times\text{DATI}
\rightarrow\text{DATI}_\perp $$

$\SC$ è una funzione di valutazione; $\SC(P,x)$ è infatti la semantica di $P$.

\subsection{Potenza computazionale di \texorpdfstring{$\SC$}{C}
\label{sec:pot_comp}}
Si definisce potenza computazionale di $\SC$:
$$ F(\SC) = \{\SC(P,\_):P\in\text{PROG}\} \subseteq \text{DATI}^{\text{DATI}}_\perp $$
\textbf{$F(\SC)$ contiene tutto ciò che un qualsiasi sistema di calcolo $\SC$
può calcolare}. Quindi, per stabilire cosa l'informatica può risolvere, basta stabilire
il carattere dell'inclusione:
\begin{itemize}
    \item $F(\SC)\subset\text{DATI}^{\text{DATI}}_\perp \Rightarrow $
        esistono problemi che l'informatica non può risolvere;
    \item $F(\SC)=\text{DATI}^{\text{DATI}}_\perp \Rightarrow $
        l'informatica può risolvere tutto.
\end{itemize}

\subsection{Cardinalità di insiemi infiniti}
Per riuscire a capire se l'inclusione
$F(\SC)\subseteq\text{DATI}^{\text{DATI}}_\perp$ sia propria o meno, si confronterà
la cardinalità dei due insiemi. Infatti dalla cardinalità si può ricavare che:
\begin{itemize}
    \item Se $|F(\SC)|<\left|\text{DATI}^{\text{DATI}}_\perp\right|
    \quad \Rightarrow \quad F(\SC)\subset\text{DATI}^{\text{DATI}}_\perp$;
    \item Se $|F(\SC)|=\left|\text{DATI}^{\text{DATI}}_\perp\right|
    \quad \Rightarrow \quad F(\SC)=\text{DATI}^{\text{DATI}}_\perp$.
\end{itemize}

Il concetto di cardinalità è semplice quando si tratta di insiemi finiti: basta
contare il numero di elementi che compongono l'insieme. Tuttavia, in presenza
di insiemi infiniti le cose si complicano.

Per esempio, si confrontino $\N$ e $\RN$: entrambi hanno cardinalità infinita
($|\N|=|\RN|=\infty$) eppure $\N\subset\RN$! Per comprendere quindi meglio
la cardinalità di insiemi infiniti si dovrà andare più nel dettaglio.

\subsubsection{Relazione binaria}
Si definisce relazione binaria $R$ sull'insieme $A$, un elenco di coppie ordinate
di elementi di $A$: $R\subseteq A^2$. Due elementi $a,b\in A$ sono in relazione 
$R$ se $(a,b)\in R$. Si usa la notazione:
\begin{itemize}
    \item $a \ R \ b$: $a$ è in relazione $R$ con $b$;
    \item $a\ \cancel{R} \ b$: $a$ non è in relazione $R$ con $b$;
\end{itemize}

\subsubsection{Relazione di equivalenza}
$R\subseteq A^2$ è una relazione di equivalenza se gode di:
\begin{enumerate}
    \item Riflessività: $\forall a \in A \quad a \ R \ a$
    \item Simmetria: $\forall a,b \in A \quad a \ R \ b \ \Leftrightarrow \ b \ R \ a$
    \item Transitività: $\forall a,b,c \in A \quad a \ R \ b
    \ \wedge \ b \ R \ c \Rightarrow a \ R \ c $
\end{enumerate}

\subsubsection{Classe di equivalenza}
Si definisce classe di equivalenza $[a]_R$ l'insieme degli elementi in relazione $R$
con $a$:
$$ [a]_R =\{b\in A: a \ R \ b\} $$

Tutte le classi di equivalenza di $R$ formano una partizione di $A$. L'insieme $A$
partizionato attraverso le classi di equivalenza di $R$ è detto \textbf{quoziente}
di $A$ rispetto a $R$ ed è denotato da $\sfrac{A}{R}$.

\subsubsection*{Esempio}
Si consideri la relazione $\equiv_4\subseteq\N^2$ di equivalenza modulo 4. Due numeri
sono in relazione di equivalenza modulo 4 se il resto della divisione per 4 è uguale
per entrambi.
$$ 5\equiv_4 9\ , \ 10\equiv_4 2 \ , \ \dots $$

Le classi di equivalenza sono:
\begin{align}
    [0]_4&=\{4k\}\tag{Multipli di 4}\\
    [1]_4&=\{4k+1\}\tag{Resto 1}\\
    [2]_4&=\{4k+2\}\tag{Resto 2}\\
    [3]_4&=\{4k+3\}\tag{Resto 3}
\end{align}
L'insieme $\{[0]_4,[1]_4,[2]_4,[3]_4\}=\sfrac{\N}{\equiv_4}$ è una partizione di $\N$.

\subsubsection{Insiemi isomorfi}
Due insiemi $A$ e $B$ sono \textbf{isomorfi} (o equinumerosi) se esiste una funzione
biettiva tra essi. Formalmente si indica con:
$$ A\sim B $$
La relazione di isomorfismo $\sim$ è una relazione di equivalenza in quanto:
\begin{enumerate}
    \item Riflessiva: si usi la funzione identità;
    \item Simmetrica: se esiste una funzione biettiva allora anche la sua inversa
        è biettiva;
    \item Transitiva: la composizione di due funzioni biettive è una funzione biettiva.
\end{enumerate}

Sia $\mathscr{U}$ l'insieme universo, ovvero l'insieme che contiene tutti gli insiemi.
Il quoziente di $\mathscr{U}$ rispetto a $\sim$ ($\sfrac{\mathscr{U}}{\sim}$) definisce il 
concetto di cardinalità:

\begin{figure}[H]
    \centering
    \input{figures/cardinalita.tex}
\end{figure}

Ogni partizione di $\sfrac{\mathscr{U}}{\sim}$ contiene gli insiemi tra loro isomorfi, ovvero
che hanno la stessa cardinalità.

\subsubsection*{Insiemi finiti}
Si definisca la famiglia di insiemi: 
$$J_n=\begin{cases}
\cancel{O} & n=0\\
\{1,\dots ,n\} & n>0
\end{cases}$$
$$ J_0=\{\}\ , \ J_1=\{1\} \ , \ J_{2}=\{1,2\} \ , \ J_{3}=\{1,2,3\}\ , \ \dots $$

Un'insieme $A$ ha cardinalità finita se $\exists n\in\N : A\sim J_n$ e si può dire che
$|A|=n$.

\subsubsection*{Insiemi infiniti}
Un insieme che non è finito ha cardinalità infinita.

\subsubsection{Insiemi numerabili}
Un insieme $A$ è numerabile se $\N\sim A$ (ovvero $A\in [\N]_\sim$). Vuole quindi dire
che esiste una biezione $f:\N\rightarrow A$ che permette di listare $A$ come:
$$ A = \{f(0),f(1),f(2),\dots\} $$
senza tralasciare nessun elemento.
\subsubsection*{Esempi}
\begin{tabular}{r l}
    PARI :& $f(n)=2n$ \\
    DISPARI :& $f(n)=2n+1$ \\
    $\mathbb{Z}$ :& mappo i pari nei non-negativi e i dispari nei negativi \\
    $\{0\}\cup 1\{0,1\}^*$ :& converto da binario a decimale \\
\end{tabular}

\subsubsection{Insiemi non numerabili}
Gli insiemi non numerabili sono insiemi a cardinalità infinita ma non listabili come
$\N$ (sono \quotes{più fitti}). Il re di questi insiemi è $\RN$.

\begin{theorem}
    $\RN$ è un insieme non numerabile: $$ \N \nsim \RN $$
\end{theorem}
\begin{proof} Per dimostrarlo dimostro che:
    \begin{enumerate}
        \item $\RN \sim (0,1)$: la biezione è rappresentata graficamente in figura:
            \vspace{-.2cm}
            \begin{figure}[H]
                \centering
                \input{figures/reali_zero_uno.tex}
            \end{figure}\vspace{-.6cm}
            (In realtà $\RN$ è isomorfo a un suo qualsiasi intervallo).
        \item $\N \nsim (0,1)$: dimostrazione per assurdo: assumo che $\N \sim (0,1)$;
            Questo vorrebbe dire che tutti i numeri compresi tra 0 e 1 sono numerabili.
            Elenco tutti i numeri associandoli a un numero naturale:

            \begin{minipage}{.45\textwidth}
                $$0\ \mapsto \ 0.{\color{red}a_{00}}\ a_{01}\ a_{02}\ a_{03}\ a_{04}\ \dots$$
                $$1\ \mapsto \ 0.a_{10}\ {\color{red}a_{11}}\ a_{12}\ a_{13}\ a_{14}\ \dots$$
                $$2\ \mapsto \ 0.a_{20}\ a_{21}\ {\color{red}a_{22}}\ a_{23}\ a_{24}\ \dots$$
                $$3\ \mapsto \ 0.a_{30}\ a_{31}\ a_{32}\ {\color{red}a_{33}}\ a_{34}\ \dots$$
                $$4\ \mapsto \ 0.a_{40}\ a_{41}\ a_{42}\ a_{43}\ {\color{red}a_{44}}\ \dots$$
                $$\vdots\qquad\vdots\qquad\vdots\qquad\vdots\qquad\vdots\qquad\ddots$$
                \vspace{.4cm}
            \end{minipage}
            \begin{minipage}{.48\textwidth}
                $a_{ij}$ è la $i$-esima cifra dopo lo zero del $j$-esimo numero
                nella lista.

                Se $(0,1)$ fosse numerabile tutti i suoi numeri dovrebbero far parte
                della lista.

                Si consideri il numero:
                $$ 0.c_0c_1c_2c_3\dots $$

                con: $$ c_i = \begin{cases}
                2 & a_{ii}\neq2\\
                3 & a_{ii}=2
                \end{cases} $$

            \end{minipage}
            Chiaramente $0.c_0c_1c_2c_3\dots\in(0,1)$ ma non appare nella lista:
            \begin{itemize}
                \item Differisce dal primo numero perchè $c_0\neq a_{00}$;
                \item Differisce dal secondo numero perchè $c_1\neq a_{11}$;
                \item $\dots$
                \item Differisce da qualunque numero nella lista sulla cifra 
                    {\color{red} diagonale}.
            \end{itemize}
            Ho trovato l'assurdo quindi $\N \nsim (0,1)$ (dimostrazione per 
            diagonalizzazione).
    \end{enumerate}
    Sfruttando la transitività di $\sim$ posso si può affermare quindi che:
    $$ \RN \underset{(1)}{\sim} (0,1) \underset{(2)}{\nsim} \N \quad \Rightarrow \quad \RN \nsim \N $$
\end{proof}

Tutti gli insiemi isomorfi a $\RN$ sono detti continui. Altri insiemi non numerabili sono:
\begin{itemize}
    \item $2^\N\nsim\N$: insieme delle parti di $\N$ ovvero $2^\N = \{\text{sottoinsiemi di } \N\}$
    \item $\N^\N_\perp\nsim\N$: insieme delle funzioni da $\N$ a $\N$ ovvero
        $\N^\N_\perp = \{f:\N\rightarrow\N_\perp\}$
\end{itemize}

\subsection{Esistono funzioni non calcolabili?}
Ora che il concetto di cardinalità è più chiaro, si riprenda il concetto di 
potenza computazionale di un sistema di calcolo $\SC$ (paragrafo \ref{sec:pot_comp}):
$$
F(\SC) = \{\SC(P,\_):P\in\text{PROG}\} \subseteq \text{DATI}^{\text{DATI}}_\perp
$$

Per definizione $F(\SC)$ ha la stessa numerosità di PROG:
$$ F(\SC) \sim \text{PROG} $$

Ragionevolmente, \textbf{ma non formalmente}, si può notare che:
\begin{itemize}
    \item PROG\ $\sim\N$: si prenda la stringa binaria con la quale il programma è
        salvato sul disco e si converta da binario a decimale;
    \item DATI\ $\sim\N$: si applichi lo stesso ragionamento del punto precedente.
\end{itemize}
Ne segue che:
$$ F(\SC) \sim \text{PROG} \sim \N \nsim\N^\N_\perp\sim \text{DATI}^\text{DATI}_\perp$$
$$ \Downarrow $$
$$ F(\SC) \nsim \text{DATI}^\text{DATI}_\perp $$
$$ \Downarrow $$
$$ F(\SC) \subset \text{DATI}^\text{DATI}_\perp $$

Quello che questa osservazione dice è che ho pochi programmi ($\N$) e troppe
funzioni ($\N^\N_\perp$).
\textbf{Alla domanda \quotes{Esistono funzioni non calcolabili?} si può quindi 
rispondere con un sì!}

\subsection{\texorpdfstring{DATI\ $\bm{\sim\N}$}{DATI~N}}
Obiettivo di questa sezione è dimostrare formalmente che:
$$ \text{DATI} \sim \N $$
Vogliamo quindi trovare una biezione che è in grado di associare biunivocamente
dei dati a un numero e quindi anche di ottenere i dati di partenza dal
numero. Per farlo si userà il seguente teorema.

\begin{theorem}
    $\N\times\N\sim\N^+$
\end{theorem}
\begin{proof}
    Si definisca la funzione coppia di Cantor $\cantor{\ ,\ }$:
    $$ \cantor{\ ,\ }:\N\times\N\rightarrow\N^+ $$
    $\cantor{\ ,\ }$ associa biunivocamente una coppia di numeri $x$ e 
    $y$ a un numero $n$:
    $$ \cantor{x,y} = n $$
    La mappa che $\cantor{\ ,\ }$ usa per assegnare i valori di ogni coppia viene 
    descritta nelle seguenti tabelle:

    \begin{minipage}{.48\textwidth}
        \centering
        \begin{tabular}{c|c c c c c c}
            $x\backslash y$&0 &1 &2 &3 &4\\ \hline
               0 &1 &3 &6 &10&15\\
               1 &2 &5 &9 &14&...\\
               2 &4 &8 &13&...&  \\
               3 &7 &12&...&  &  \\
               4 &11&...&  &  &  \\
               5 &$\nearrow$&&&&\\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.48\textwidth}
        \centering
        \input{figures/tabella_cantor.tex}
    \end{minipage}

    Si vuole calcolare ora la forma analitica di $\cantor{\ ,\ }$; si prenda una generica
    coppia di numeri $\cantor{x,y}$:

    \begin{minipage}{.4\textwidth}
        \centering
        \input{figures/cantor_analitica.tex}
    \end{minipage}
    \begin{minipage}{.58\textwidth}
        Per come è definita $\cantor{x,y}$ (vedi tabella precedente) si ha che:
        \begin{equation}\label{eq:cantor_analytic}
            \cantor{x,y} = {\color{blue}\cantor{x+y,0}}{\color{red}+y}
        \end{equation}

        Ora l'incognita da calcolare resta $\color{blue}\cantor{z,0}$ che,
        si può ottenere come:
        \begin{equation}\label{eq:cantor_analytic_2}
            \cantor{z,0} = \sum_{i=0}^z i+1 = \frac{z(z+1)}{2}+1
        \end{equation}
    \end{minipage}
    
    Da (\ref{eq:cantor_analytic}) e (\ref{eq:cantor_analytic_2}) segue che:
    $$ \cantor{x,y} = \cantor{x+y,0}+y = \frac{(x+y)(x+y+1)}{2}+y+1 $$
    
    $\cantor{\ ,\ }$ si dimostra quindi mappare univocamente le coppie di numeri
    in numeri ($\N^2\rightarrow\N^+$). Si cercherà ora di mostrare il passaggio inverso, 
    ovvero come riottenere la coppia di numeri dal numero risultante
    ($\N^+\rightarrow\N^2$).

    Si definiscano le seguenti funzioni:
    $$ \cantor{x,y} = n \quad , \quad \sx(n) = x \quad , \quad \dx(n) = y $$

    Da (\ref{eq:cantor_analytic}) si ha che:
    $$ \begin{aligned}
        y &= \cantor{x,y}-\cantor{x+y,0} \\
          &= n-\cantor{x+y,0} \\
          &= n-\cantor{\gamma,0} \\
    \end{aligned} $$
    Il valore di $\gamma$ è il più grande valore che, messo sulla prima colonna
    ($\cantor{\gamma,0}$), non supera $n$:
    $$ \gamma = \max\{z\in\N:\cantor{z,0}\leq n\} $$
    $$ \cantor{z,0}\leq n $$
    $$ \frac{z(z+1)}{2}+1 \leq n $$
    $$ z^2+z+2-2n\leq 0 $$
    $$ \frac{-1-\sqrt{8n-7}}{2}\leq z \leq \frac{-1+\sqrt{8n-7}}{2} $$
    $$ \Downarrow $$
    $$ \gamma=\left\lfloor\frac{-1+\sqrt{8n-7}}{2}\right\rfloor $$
    
    In conclusione:
    $$ \dx(x) = n-\cantor{\gamma,0} $$
    \begin{equation} \sx(x) = \gamma-des(x) \tag{non è il seno} \end{equation}

    La funzione coppia di Cantor $\cantor{\ ,\ }$ si è quindi mostrata
    essere una biezione tra $\N^+$ e $\N^2$, mostrando che i due insiemi
    hanno la stessa cardinalità.
\end{proof}

È facile poi, partendo da $\cantor{\ ,\ }$, creare una biezione tra $\N$ e $\N^2$
(dimostrando che $\N\times\N\sim\N$):
$$ [\ ,\ ]:\N\times\N\rightarrow\N $$
$$ [x,y] = \cantor{x,y}-1 $$

Il precedente risultato mette alla luce anche che:
$$ \mathbb{Q}\sim\N $$
in quanto ogni suo elemento non è altro che una coppia di numeri messi
a frazione.

Ora che si ha appurato l'esistenza di una biezione tra coppie di numeri e numeri si può
facilmente estendere questa relazione a liste d'interi, dove con lista si intende una
sequenza di numeri di lunghezza non nota:
$$ x_1,x_2,\dots,x_m \rightarrow \cantor{x_1,x_2,\dots,x_m} $$
Per farlo basterà applicare $\cantor{\ ,\ }$ come segue:
$$ \cantor{x_1,x_2,\dots,x_m} = 
\cantor{x_1,\cantor{x_2,\cantor{\dots,\cantor{x_m,0}\dots}}} $$
Dove lo 0 a destra della coppia di Cantor più interna rappresenta il fine lista.

La decodifica invece avverrà nel seguente modo:
\begin{figure}[H]
    \centering
    \input{figures/cantor_list_dec.tex}
\end{figure}

Se si conosce il numero di elementi della sequenza di numeri, non si usa una lista ma un
\textbf{array}:
$$ [x_1,\dots,x_n] = [x_1,[x_2,[\dots,[x_{n-1},x_n]]\dots]] $$
Conoscendo già la lunghezza non c'è bisogno dello 0 di fine lista.

Qualsiasi tipo di dato può essere convertito a una lista di numeri:
\begin{itemize}
    \item Testi: non sono altro che liste di caratteri i quali possono essere convertiti
        in numeri tramite tabella ASCII;
    \item Suoni: si usa un campionamento a una data frequenza ottenendo una lista di
        valori;
    \item Matrici: una matrice è una lista di liste;
    \item Immagini: ogni pixel contiene la codifica numerica di un colore; in questo modo
    un'immagine non è altro che una matrice di numeri grande quanto la sua risoluzione;
    \item Grafi: uso liste o matrici di adiacenza.
\end{itemize}

\textbf{Si può quindi affermare che $\bm{\text{DATI}\sim\N}$}.

\subsection{\texorpdfstring{PROG\ $\bm{\sim\N}$}{PROG~N}}
Obiettivo di questa sezione è dimostrare formalmente che:
$$ \text{PROG} \sim \N $$
Per poterlo fare si dovrà definire formalmente un sistema di calcolo specifico: il sistema 
di calcolo RAM, composto dalla macchina RAM e il linguaggio RAM. Quest'ultimo si può 
riassumere come un assembly molto semplificato.

L'idea è di usare il sistema RAM come rappresentativo di tutti i possibili sistemi di calcolo;
ne segue che $F(\RAM)$, ovvero la potenza computazionale di un sistema RAM, permetterà
di capire cosa i sistemi di calcolo sono in grado di calcolare.

Può però sorgere spontaneo un dubbio: il sistema RAM non è troppo semplice per rappresentare
tutti i sistemi di calcolo? Se il sistema RAM non fosse in grado di risolvere
certi problemi, magari altri sistemi più complessi lo sarebbero.

Per verificare questo caso si vedrà successivamente un altro sistema di calcolo più
sofisticato: quello WHILE. Il confronto tra le due potenze computazionali porterebbe a:
\begin{itemize}
    \item $F(\WHILE)\neq F(RAM) \Rightarrow$ la computabilità dipende dallo strumento usato;
    \item $F(\WHILE)=F(RAM) \Rightarrow$ la computabilità è intrinseca nei problemi 
        (tesi di Church-Turing).
\end{itemize}

\subsubsection{Sistema di calcolo RAM}
\subsubsection*{Macchina RAM}
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram.tex}
\end{figure}
\begin{itemize}
    \item $L$ contiene l'indirizzo della prossima istruzione da eseguire ($1\leq L\leq |P|$)
    \item $P$ è il programma ovvero una lista di istruzioni $\text{Istr}_i$
    \item $R_i$ è un generico registro di memoria che può contenere un numero naturale:
    \begin{itemize}
        \item $R_0$ è il registro specifico dove verrà deposto l'output del programma
        \item $R_1$ è il registro specifico dove verrà letto l'input del programma
        \item Il numero dei registri è illimitato
    \end{itemize}
\end{itemize}
\subsubsection*{Linguaggio RAM}
La sintassi del linguaggio RAM è molto intuitiva; ci sono tre tipi di istruzioni:

\begin{minipage}{.4\textwidth}
    \begin{enumerate}
        \itemsep.5em 
        \item $R_k \leftarrow R_k +1$ 
        \item $R_k \leftarrow R_k \dotminus 1$
        \item $\goto{R_k}{m}$
    \end{enumerate}
\end{minipage}
\begin{minipage}{.49\textwidth}
    $$x\dotminus y =\begin{cases}x-y&x\geq y\\ 0 &\text{altrimenti}\end{cases}$$
\end{minipage}

Si noti che il numero di istruzione $m$ usato nel terzo comando deve essere compreso tra
1 e $|P|$ inclusi.

\subsubsection*{Esecuzione}
Per eseguire un programma $P$ su input $\color{red}n$ la macchina verrà inizializzata come segue:
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram_init.tex}
\end{figure}

Successivamente si eseguirà un'istruzione dopo l'altra, a partire dalla prima, facendo quindi
incrementare di uno il program counter ($L\leftarrow L+1$) dopo l'esecuzione di ogni istruzione.
Se l'istruzione è un'istruzione di salto ($\goto{R_k}{m}$) e la sua condizione $R_k=0$
è verificata, il program counter verrà cambiato in $L\leftarrow m$.

Per convenzione $L=0 \Rightarrow \text{ Fine del programma}$ (con possibiliità di loop infinito).

L'output del programma sarà il contenuto di $R_0$ o $\perp$ in presenza di loop.

\subsubsection*{Semantica operazionale}
La semantica operazionale descrive formalmente il significato di ogni istruzione; per farlo
specifica l'effetto che l'istruzione ha sui registri della macchina.

L'esecuzione di un programma è una sequenza di stati della macchina, dove uno stato descrive
precisamente l'attuale situazione della macchina. Ogni istruzione fa passare la macchina da
uno stato ad un altro:
$$ \text{STATO}_1 \rightarrow \boxed{\text{Istr}_i} \rightarrow \text{STATO}_2 $$
$$ (\text{STATO}_1,\text{STATO}_2) = \text{semantica operazionale di Istr}_i $$

Ampliando il concetto di semantica dalla singola istruzione all'intero programma si ha che 
quest'ultimo induce una sequenza di stati:
\begin{figure}[H]
    \centering
    \input{figures/macchina_ram_stati.tex}
\end{figure}

La semantica di $P$ è:
$$ \semanticaRAM_P:\N\to\N_\perp $$
$$ \semanticaRAM_P(n) = \begin{cases}
\perp & \text{se $P$ va in loop}\\
y & \text{altrimenti}
\end{cases} $$

\subsubsection*{Stato}
Come già anticipato, uno stato è una \quotes{foto} di tutte le componenti della macchina
in un dato istante. Formalmente si definisca uno stato come una funzione:
$$ \Stato:\{L,R_i\}\to\N $$
$$ \Stato(R_j) = \text{contenuto del registro $R_j$ quando la macchina è nello stato 
$\Stato$}$$

I possibili stati della macchina sono:
$$ \text{STATI} = \N^{\{L,R_i\}} $$

Uno stato è finale se $\Stato(L)=0$.

La funzione di inizializzazione $in$, preso l'input del programma, restituisce lo stato
iniziale:
$$ in:\text{DATI}\to\text{STATI} $$
$$ in(n) = \Stato_{init} $$
$$ \Stato_{init}(L) = 1 \qquad\qquad \Stato_{init}(R_i) = \begin{cases}
n & i=1\\
0 & i\neq 1
\end{cases} $$

\subsubsection*{Funzione stato prossimo}
A definire la dinamica del programma è la funzione stato prossimo $\delta$:
$$ \delta : \text{STATI}\times\text{PROG}\to\text{STATI}_\perp $$
$$ \delta({\color{red}\Stato},P) = {\color{blue}\Stato'} $$
$$ {\color{red}\text{Stato attuale}} \qquad {\color{blue}\text{Stato prossimo}} $$

\begin{enumerate}
    \item Se $\Stato(L)=0$ allora $\Stato'=\perp$
    \item Se $\Stato(L)>|P|$ allora $\Stato'(L)=0$ e $\forall i:\Stato'(R_i)=\Stato(R_i)$
    \item Se $1\leq\Stato(L)\leq |P|$: considera la $\Stato(L)$-esima istruzione:
        \begin{enumerate}
            \item Se $R_k \leftarrow R_k +/\dotminus 1$ allora:
                \begin{itemize}
                    \item $\Stato'(R_k) = \Stato(R_k)+/\dotminus 1$
                    \item $\Stato'(L) = \Stato(L)+1$
                    \item $\forall i:i\neq k \quad \Stato'(R_i) = \Stato(R_i)$
                \end{itemize}
            \item Se $\goto{R_k}{m}$ allora:
                \begin{itemize}
                    \item Se $\Stato(R_k)=0$ allora $\Stato'(L) = m$
                    \item Altrimenti $\Stato'(L) = \Stato(L)+1$
                \end{itemize}
        \end{enumerate}
\end{enumerate}

\subsubsection*{Esempio di programma}
\vspace{-1em}
\begin{minipage}{.48\textwidth}
    \begin{align}
        P \equiv\ & \goto{R_1}{6}       \notag\\
        & R_0 \leftarrow R_0+1          \notag\\
        & R_0 \leftarrow R_0+1          \notag\\[-.3em]
        & R_1 \leftarrow R_1\dotminus 1 \notag\\
        & \goto{R_2}{1}                 \notag\\[-.3em]
        & R_1 \leftarrow R_1\dotminus 1 \notag
    \end{align}
\end{minipage}
\begin{minipage}{.48\textwidth}
    $ \semanticaRAM_P(n) = 2n $
\end{minipage}

\subsubsection*{Aritmetizzazione di un programma RAM}
Essendo un programma RAM una lista di istruzioni, per poter codificare e decodificare
dei programmi basterà trovare una funzione $Ar$ che codifica le singole istruzioni, 
ottenenendo una lista di numeri che si può facilmente codificare con $\cantor{\ ,\ }$:
\begin{figure}[H]
    \centering
    \input{figures/ram_codifica.tex}
\end{figure}

L'associazione biunivoca di un numero ad una struttura si dice aritmetizzazione o
Gödellizzazione.

\subsubsection*{Aritmetizzazione delle istruzioni RAM}
Per poter aritmetizzare un'istruzione RAM c'è bisogno di una funzione che:
$$ Ar:\text{Istr}\to\N \quad , \quad Ar^{-1}:\N\to\text{Istr} $$
Il linguaggio RAM è formato da tre tipi di istruzioni; si può quindi ottenere la
seguente aritmetizzazione:
$$ \begin{aligned}
    Ar(R_k\leftarrow R_k+1) &= 3k\\
    Ar(R_k\leftarrow R_k\dotminus1) &= 3k+1\\
    Ar(\goto{R_k}{m}) &= 3\cantor{k,m}-1
\end{aligned} $$
Mentre per calcolare la sua inversa $Ar^{-1}$, ovvero a partire da un numero $n$ decodificare
l'istruzione:
\begin{itemize}
    \item Se $n\bmod{3}=0$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di primo tipo
                \item $n=3k$
            \end{minipage}
            \begin{minipage}{.3\textwidth}
                $\Rightarrow \qquad R_{\frac{n}{3}} \leftarrow R_{\frac{n}{3}}+1$
            \end{minipage}
        \end{itemize}
    \item Se $n\bmod{3}=1$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di secondo tipo
                \item $n=3k+1$
            \end{minipage}
            \begin{minipage}{.3\textwidth}
                $\Rightarrow \qquad R_{\frac{n-1}{3}} \leftarrow R_{\frac{n-1}{3}}\dotminus1$
            \end{minipage}
        \end{itemize}
    \item Se $n\bmod{3}=2$:
        \begin{itemize}
            \begin{minipage}{.35\textwidth}
                \item È un'istruzione di terzo tipo
                \item $n=3\cantor{k,m}-1$
            \end{minipage}
            \begin{minipage}{.5\textwidth}
                $\Rightarrow \qquad \goto{R_{\sx(\frac{n+1}{3})}}{\dx(\frac{n+1}{3})}$
            \end{minipage}
        \end{itemize}
\end{itemize}

\subsubsection*{Potenza computazionale del sistema RAM}
$$ \begin{aligned}
        F(\RAM) &= \{f\in\N_\perp^\N:\exists P \in \PROG: \semanticaRAM_P=f\}\\
                &= \{\semanticaRAM_P:P\in\PROG\} \subset \N_\perp^\N \\
                \multispan2{Vista la possibilità di rappresentare un programma
                 con un numero si ha:\hfill}\notag\\
                 &= \{\semanticaRAM_i:i\in\N\}
\end{aligned} $$
Dove $\semanticaRAM_i$ è la semantica del programma la cui codifica è $i$.
\subsubsection*{Conclusioni}
Nelle ultime sezioni si è mostrata una biezione tra programmi RAM (PROG) e numeri
($\N$):
    \begin{itemize}
        \item Da programmi a numeri:
            $cod(P)=\cantor{Ar(\text{Istr}_1),Ar(\text{Istr}_2),\dots,Ar(\text{Istr}_m)}$
        \item Da numeri a programmi: si decodifichi la lista di numeri e si applichi su
            ogni numero $Ar^{-1}$
    \end{itemize}
Per quanto riguarda i programmi RAM, \textbf{si può quindi affermare che}:
$$ F(\RAM) \sim \N \nsim \N^\N_\perp $$
e quindi esistono problemi non risolubili automaticamente da una macchina RAM.
\subsubsection{Sistema di calcolo WHILE}
Per mostrare se il concetto di calcolabilità è legato al sistema di calcolo o meno,
se ne vedrà uno più sofisticato: quello WHILE.
\subsubsection*{Macchina WHILE}
La macchina WHILE è più semplice di quella RAM; è formata infatti da un'unica memoria
con un numero finito di registri:
$$\text{Memoria: } x_0,x_1,x_2,\dots,x_{20}$$
\begin{itemize}
    \item $x_i$ è un generico registro di memoria detto variabile:
        \begin{itemize}
            \item $x_0$ è la variabile specifica dove verrà deposto l'output del programma
            \item $x_1$ è la variabile specifica dove verrà letto l'input del programma
            \item Ci sono 21 variabili
        \end{itemize}
    \item Non c'è un Program Counter
\end{itemize}

\subsubsection*{Linguaggio WHILE}
La sintassi del linguaggio WHILE è induttiva; le istruzioni, dette comandi, sono:
\begin{itemize}
    \item Comando di assegnamento:
        \begin{enumerate}
            \item $x_k := 0$
            \item $x_k := x_j+1$
            \item $x_k := x_j\dotminus 1$
        \end{enumerate}
    \item Comando WHILE:
        \begin{enumerate}
            \item $\while{x_k} C$
        \end{enumerate}
    \item Comando composto:
        \begin{enumerate}
            \item $\textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend$
        \end{enumerate}
    \end{itemize}
dove $C_i$ è un comando WHILE.

Un programma WHILE è un comando composto.

\subsubsection*{Semantica programma WHILE}
La semantica di un programma $W$ è la funzione
    $$\semanticaWHILE_W:\N\to\N_\perp$$
\subsubsection*{Esempio di programma}
\vspace{-1em}
\begin{minipage}{.34\textwidth}
    \begin{align}
        W \equiv\ & \textbegin                      \notag\\[-.3em]
        & \qquad x_2 := x_1+1;                      \notag\\[-.3em]
        & \qquad x_2 := x_2\dotminus 1;             \notag\\[-.3em]
        & \qquad \while{x_1}                        \notag\\[-.3em]
        & \qquad\qquad \textbegin                   \notag\\[-.3em]
        & \qquad\qquad\qquad x_0 := x_0+1;          \notag\\[-.3em]
        & \qquad\qquad\qquad x_1 := x_1\dotminus 1; \notag\\[-.3em]
        & \qquad\ \ \ \ \ \textend                  \notag\\[-.3em]
        & \qquad \while{x_2}                        \notag\\[-.3em]
        & \qquad\qquad \textbegin                   \notag\\[-.3em]
        & \qquad\qquad\qquad x_0 := x_0+1;          \notag\\[-.3em]
        & \qquad\qquad\qquad x_2 := x_2\dotminus 1; \notag\\[-.3em]
        & \qquad\ \ \ \ \ \textend                  \notag\\[-.3em]
        & \hspace{-.5em}\textend                            \notag
    \end{align}
\end{minipage} \hspace{1em}
\begin{minipage}{.6\textwidth}
    $\qquad\qquad\ \ \ \semanticaWHILE_W(n) = 2n $
\end{minipage}

\subsubsection*{W-PROG e induzione}
Sia W-PROG l'insieme dei programmi WHILE. La sua definizione è induttiva; per dimostrare
una proprietà $P$ su W-PROG sarà quindi naturale farlo tramite induzione.

\subsubsection*{Stato}
Siccome la macchina WHILE è composta solo da 21 variabili, uno stato della macchina è
una lista di 21 numeri:
$$ \text{STATO} = (c_0,c_1,\dots,c_{20}) $$
$$ c_i = \text{contenuto di $x_i$} $$
$$ \text{W-STATI} = \N^{21} $$
$$ \underbar{$x$}\in\N^{21} $$

La funzione $W$-$in:\N\to\N^{21}$ restituisce lo stato iniziale del programma $W$:
$$ W\text{-}in(n) = (0,n,0,\dots,0) $$

\subsubsection*{Funzione stato prossimo}
Si definisca la funzione stato prossimo e quindi la semantica operazionale:
$$\opsemWHILE{\ }{\ }: \text{W-COM}\times\text{W-STATI}\to\text{W-STATI}_\perp$$
dato un comando $C$ e uno stato $\underbar{x}$:
$$ \opsemWHILE{C}{\sottolinea{x}} = \sottolinea{y} $$
dove $\sottolinea{y}$ è lo stato prossimo di $\sottolinea{x}$ a seguito dell'esecuzione del
comando $C$.

Si veda ora la definizione induttiva della semantica operazionale:
\begin{itemize}
    \item (BASE) Assegnamenti
        \begin{itemize}
            \item $\opsemWHILE{x_k:=0}{\sottolinea{x}} = \sottolinea{y}$ con
                $y_i = \begin{cases}
                    x_i & i\neq k\\
                    0 & i= k\\
                \end{cases}$
            \item $\opsemWHILE{x_k:=x_j \pm 1}{\sottolinea{x}} = \sottolinea{y}$ con
                $y_i = \begin{cases}
                    x_i & i\neq k\\
                    x_j\pm 1 & i= k\\
                \end{cases} \hfill \text{(con $\pm$ si intende $+$ o $\dotminus$)}$
        \end{itemize}
    \item (PASSO) Comando composto
        \begin{itemize}
            \item $
                \opsemWHILE{\textbegin C_1 \ ; \ \dots \ ; \ C_m\textend}{\sottolinea{x}}
                = \opsemWHILE{C_m}{
                    \dots(
                        \opsemWHILE{C_2}{
                            \opsemWHILE{C_1}{\sottolinea{x}}
                        }
                    )\dots
                }$
            \item[]\hspace{14.1em}$=\opsemWHILEnoP{C_m}\circ\hdots\circ\opsemWHILEnoP{C_1}(\sottolinea{x})$
            \item[]\hspace{14.1em}$=\sottolinea{y}$
        \end{itemize}
    \item (PASSO) Comando WHILE
        \begin{itemize}
            \item $
            \opsemWHILE{\while{x_n} C}{\sottolinea{x}} =
            \opsemWHILE{C}{
                \dots(
                \opsemWHILE{C}{
                    \opsemWHILE{C}{\sottolinea{x}}
                })
                \dots
            }=\sottolinea{y}
            $
            \item[]\hspace{11.7em}$=
                \begin{cases}
                    \opsemWHILEnoP{C}^e(\sottolinea{x}) & e=
                    \mu t(\text{componente $k$ di $\opsemWHILEnoP{C}^t(\sottolinea{x})=0$})\\
                    \perp & \text{altrimenti (se non esiste $e)$}
                \end{cases}
            $
            \\[.6em]dove $\mu t (\text{condizione}) = \underset{t}{\min}\{\text{condizione vera\}}$
        \end{itemize}
\end{itemize}
Si può quindi definire la semantica di un programma $W$:
$$\semanticaWHILE_W(n) = \Pro(0,\opsemWHILE{W}{\text{$W$-$in$}(n)})$$
dove Pro è la funzione proiezione:
$$ \Pro(i,(x_0,x_1,\dots,x_m)) = x_i $$

\subsubsection*{Potenza computazionale del sistema WHILE}
$$ \begin{aligned}
    F(\text{WHILE}) &= \{ f\in\N^\N_\perp : \exists W\in \text{W-PROG}:f=\semanticaWHILE_W \}\\
    &= \{ \semanticaWHILE_W : W \in \text{W-PROG} \} 
    \end{aligned}
$$

\subsubsection{Traduzione}
Dati i sistemi di calcolo $\SC_1$ e $\SC_2$, una traduzione da $\SC_1$ a $\SC_2$ è una funzione
$$ T:\SC_1\text{-PROG}\to\SC_2\text{-PROG} $$
tale che $T$ sia:
\begin{enumerate}
    \item Programmabile: è programmabile effettivamente
    \item Completa: traduce ogni programma
    \item Corretta: mantiene la semantica:
        $\forall P\in\SC_1\text{-PROG} \quad \semanticaRAM_{T(P)}=\semanticaWHILE_{P}$
\end{enumerate}
\subsubsection{Confronto tra sistemi di calcolo}
Si prendano due sistemi di calcolo $\SC_1$ e $\SC_2$ con le rispettive potenze computazionali:
$$ F(\SC_1) = \{\semanticaRAM_{P_1}:P_1\in\SC_1\text{-PROG}\} $$
$$ F(\SC_2) = \{\semanticaWHILE_{P_2}:P_2\in\SC_2\text{-PROG}\} $$

Si vuole mostrare che $F(\SC_1)\subseteq F(\SC_2)$, ovvero che $\SC_1$ non è più potente di $\SC_2$;
per farlo bisogna dimostrare che:
\begin{table}[H]
    \centering
    \begin{tabular}{c}
        $\forall f \in F(\SC_1) \quad f\in F(\SC_2)$\\[1em]
        \rotatebox[origin=c]{90}{$\equiv$}\\[1em]
        $\exists P_1\in\SC_1\text{-PROG}:f=\semanticaRAM_{P_1}
    \ \Rightarrow \ \exists P_2\in\SC_2\text{-PROG}:f=\semanticaWHILE_{P_2}$
    \end{tabular}
\end{table}
In altre parole, per ogni programma di $\SC_1$ ne esiste uno equivalente in $\SC_2$.
\\
\begin{theorem}\label{theo:traduttore}
    Se esiste una traduzione $T$ da $\SC_1$ a $\SC_2$, allora $F(\SC_1)\subseteq F(\SC_2)$.
\end{theorem}
\begin{proof}
    Si prenda una funzione $f$ tale che:
    $$ f\in F(\SC_1) $$
    Si ha quindi che esiste un programma in $\SC_1\text{-PROG}$ che può calcolare $f$:
    \begin{equation} \label{eq:traduzione_proof1}
        \exists P\in\SC_1\text{-PROG}:f=\semanticaWHILE_P
    \end{equation}
    Si prenda la traduzione $T$ da $\SC_1$ a $\SC_2$; vista la completezza di $T$ si ha che:
    \begin{equation} \label{eq:traduzione_proof2}
        T(P)\in\SC_2\text{-PROG}
    \end{equation}
    e vista la correttezza si ha che:
    \begin{equation} \label{eq:traduzione_proof3}
        \semanticaRAM_{T(P)}=\semanticaWHILE_P\underset{(\ref{eq:traduzione_proof1})}{=}f
    \end{equation}
    Si ha quindi che esiste un programma $T(P)$ in $\SC_2$-PROG (\ref{eq:traduzione_proof2})
    la cui semantica è $f$ (\ref{eq:traduzione_proof3}). Si può concludere che:
    $$ f\in F(\SC_2) $$ 
\end{proof}

\textbf{Quindi, per mostrare che un sistema di calcolo $\SC_1$ non è più potente di un 
altro sistema $\SC_2$, basterà trovare una traduzione da $\SC_1$ a $\SC_2$}. 

\subsubsection{\texorpdfstring{$\bm{F(\text{WHILE})\subseteq F(\text{RAM})}$}
{F(WHILE) sottoinsieme F(RAM)}}\label{sec:FwhileFram}
In questa sezione si mostrerà che il una macchina WHILE \textbf{non} è più potente di
una macchina RAM. Per farlo, come suggerisce il teorema \ref{theo:traduttore}, verrà
mostrata una traduzione da W-PROG a PROG; la funzione di traduzione viene detta
compilatore:
$$ Comp:\text{W-PROG}\to\text{PROG} $$
Per comodità si userà un linguaggio RAM etichettato, dove nell'istruzione di \texttt{GOTO}
si useranno delle etichette e non il numero dell'istruzione. Questo non influenzerà
in alcun modo la potenza del linguaggio.

\subsubsection*{Compilatore}
Vista la natura induttiva di W-PROG, anche $Comp$ verrà definita induttivamente:
\begin{enumerate}
    \item (BASE) Compilazione degli assegnamenti:
        \begin{itemize}
            \renewcommand{\labelitemi}{\raisebox{5.8\height}{\textbullet}}
            \item
                \renewcommand{\arraystretch}{1.25}
                \begin{tabular}{l|r l|}\cline{2-3}
                $Comp(x_k:=0)=$ & \texttt{LP}:&$\goto{R_k}{\texttt{EX}}$\\
                && $R_k\leftarrow R_k\dotminus 1$ \\
                && $\goto{R_{21}}{\texttt{LP}}$ \\
                &\texttt{EX}:& $R_k \leftarrow R_k\dotminus 1$ \\\cline{2-3}
                \end{tabular}\vspace{.15cm}
            \renewcommand{\labelitemi}{\textbullet}
            \item $\ \ Comp(x_k:=x_j+/\dotminus 1) \ $=
                \begin{itemize}
                    \renewcommand{\labelitemii}{\raisebox{.1\height}{$-$}}
                    \item \renewcommand{\arraystretch}{1.25}
                        \begin{tabular}{r|l|} \cline{2-2}
                         Se $k=j$: &$R_k \leftarrow +/\dotminus 1$\\ \cline{2-2}
                        \end{tabular}
                    \renewcommand{\labelitemii}{\raisebox{15.5\height}{$-$}}
                    \item
                        \renewcommand{\arraystretch}{1.25}
                        \begin{tabular}{l|r l|l}\cline{2-3}
                         Se $k\neq j$: & \texttt{LP}:&$\goto{R_j}{\texttt{E1}}$
                                &\multirow{4}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$ Salva $R_j$ in $R_{22}$
                                }\\
                        && $R_{22}\leftarrow R_{22}+1$ \\
                        && $R_{j}\leftarrow R_{j}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{LP}}$ \\
                        &\texttt{E1}:& $\goto{R_k}{\texttt{E2}}$
                                &\multirow{3}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$ Azzera $R_k$
                                }\\
                        && $R_{k}\leftarrow R_{k}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{E1}}$ \\
                        &\texttt{E2}:& $\goto{R_{22}}{\texttt{E3}}$
                                &\multirow{5}{*}{\hspace{-.2cm}
                                    $\begin{rcases}
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \phantom{}\\
                                    \end{rcases}$  Rigenera $R_j$ e $R_k$ da $R_{22}$ 
                                }\\
                        && $R_{k}\leftarrow R_{k}+1$ \\
                        && $R_{j}\leftarrow R_{j}+1$ \\
                        && $R_{22}\leftarrow R_{22}\dotminus 1$ \\
                        && $\goto{R_{21}}{\texttt{E2}}$ \\
                        &\texttt{E3}:& $R_k\leftarrow R_k+/\dotminus 1$ \\ \cline{2-3}
                        \end{tabular}\vspace{.5cm}
                \end{itemize}
        \end{itemize}
    \item (PASSO) Per ipotesi induttiva si assumi data la compilazione di un comando
        $C$:
        \begin{enumerate}
            \item Compilazione di comando composto:
                \begin{itemize}
                    \renewcommand{\labelitemi}{\raisebox{6.6\height}{\textbullet}}
                    \item \renewcommand{\arraystretch}{1.25} 
                        \begin{tabular}{l| l|}\cline{2-2}
                        $Comp(\textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend)=$&
                            $Comp(C_1)$\\
                            & $Comp(C_2)$\\
                            & $\vdots$\\
                            & $Comp(C_m)$\\ \cline{2-2}
                    \end{tabular}
                \end{itemize}
            \item Compilazione di comando WHILE:
                \begin{itemize}
                    \renewcommand{\labelitemi}{\raisebox{6\height}{\textbullet}}
                    \item \renewcommand{\arraystretch}{1.25} 
                        \begin{tabular}{l|r l|}\cline{2-3}
                        $Comp(\while{x_k}C)$ =& \texttt{LP}:&
                            $\goto{R_k}{\texttt{EX}}$\\
                            && $Comp(C)$\\
                            && $\goto{R_{21}}{\texttt{LP}}$\\
                            &\texttt{EX}:& $R_k\leftarrow R_k\dotminus 1$\\ \cline{2-3}
                    \end{tabular}
                \end{itemize}
        \end{enumerate}
\end{enumerate}

\subsubsection*{Conclusioni}
La funzione $Comp:\text{W-PROG}\to\text{PROG}$ precedentemente definita soddisfa le tre
condizioni di una traduzione:
\begin{enumerate}
    \item È programmabile
    \item Compila sempre
    \item Mantiene la semantica
\end{enumerate}

Si ha quindi che $Comp$ è una traduzione da W-PROG a PROG e che:
$$ F(\text{WHILE})\subseteq F(\text{RAM}) $$

\subsubsection{\texorpdfstring{$\bm{F(\text{RAM})\subseteq F(\text{WHILE})}$}
{F(RAM) sottoinsieme F(WHILE)}}\label{sec:FramFwhile}
Ora che si è mostrato che una macchina WHILE non è più potente di una RAM, si mostrerà
l'inverso.

Per farlo si userà il concetto di interprete.
\subsubsection*{Interprete}
A differenza di un compilatore un interprete non produce nessun oggetto ma esegue
direttamente tutte le istruzioni del programma. In altre parole, un interprete è
un programma che prende in ingresso un altro programma $P$ e un dato $x$ e restituisce
il risultato della semantica di $P$ su $x$ ovvero $\semanticaRAM_P(x)$.

\subsubsection*{Interprete WHILE di programmi RAM}
Si definirà ora un interprete $I_W$ scritto in WHILE di programmi RAM.
\begin{figure}[h]
    \centering
    \input{figures/interprete1.tex}
\end{figure}

\begin{tabular}{l p{.83\textwidth}}
    Problema:& un programma WHILE prende in input solo numeri; non è in grado di leggere 
    un programma RAM \quotes{puro}. $P$\\[1.6em]
    Soluzione:& codifico $P$ in un numero $n$.
\end{tabular}
\begin{figure}[h]
    \centering
    \input{figures/interprete2.tex}
\end{figure}

\begin{tabular}{l p{.83\textwidth}}
    Problema:& un programma WHILE prende in input solo un numero.\\[.5em]
    Soluzione:& aggrego $n$ e $x$ tramite la funzione coppia di Cantor.
\end{tabular}
\begin{figure}[h]
    \centering
    \input{figures/interprete3.tex}
\end{figure}

La semantica dell'interprete $I_W$ è:
$$\forall x,n\in\N: \semanticaWHILE_{I_W}(\cantor{x,n})
=\semanticaRAM_n(x)=\semanticaWHILE_P(x)$$

Per questioni di comodità si usera una variante di WHILE in cui si potranno definire
delle macro, ovvero delle chiamate a funzioni comunque definibili in WHILE puro; alcuni
esempi di macro sono:
\begin{itemize}
    \item $x_k:=x_j+x_s$
    \item $x_k:=\cantor{x_j,x_s}$\hfill coppia di Cantor
    \item $x_k:=\cantor{a_1,a_2,\dots,a_N}$\hfill \quotes{lista di Cantor}
    \item $x_k:=\Pro(x_j,x_s)$ \hfill estrae dalla lista codificata $x_s$ il
        $x_j$-esimo elemento
    \item $x_k:=\text{incr}(x_j,x_s)$\hfill codifica la lista $x_s$ in cui il $x_j$-esimo elemento
        viene incrementato di 1
    \item $x_k:=\text{decr}(x_j,x_s)$\hfill codifica la lista $x_s$ in cui il $x_j$-esimo elemento
    viene decrementato di 1
    \item $x_k:=\sx(x_j)$\hfill estrae l'elemento sinistro dalla codifica di Cantor $x_j$
    \item $x_k:=\dx(x_j)$\hfill estrae l'elemento destro dalla codifica di Cantor $x_j$
    \item \texttt{if}$\dots$\texttt{then}$\dots$\texttt{else}
\end{itemize}

\subsubsection*{Stato della macchina RAM nell'interprete}
L'interprete $I_W$ per eseguire il programma $P$ ricrea nelle sue variabili lo stato
della macchina RAM in cui verrebbe eseguito $P$.

\begin{tabular}{l p{.83\textwidth}}
    Problema:& la macchina RAM ha infiniti registri mentra quella WHILE ne ha ventuno.
        \\[.5em]
    Soluzione:& un programma $P$ userà sempre un numero finito di registri il cui contenuto
        può essere racchiuso in una lista di valori $a_0,a_1,\dots,a_n$; la soluzione
        consiste nel raggruppare tutti i valori dei registri tramite Cantor:
        $$ \cantor{a_1,a_2,\dots,a_n} $$ e salvarne la codifica in un unica variabile.
\end{tabular}

$I_W$ salva lo stato della macchina RAM nel seguente modo:
\begin{itemize}
    \item $x_0 \leftarrow \cantor{R_0,\dots,R_{n}}$\hfill
        stato della memoria RAM del programma P con $cod(P)=n$
    \item $x_1 \leftarrow L$ \hfill program counter
    \item $x_2 \leftarrow x$ \hfill dato di input del programma $P$
    \item $x_3 \leftarrow n$ \hfill lista di istruzioni che formano $P$
    \item $x_4 \leftarrow \text{codice dell'istruzione da eseguire}$
\end{itemize}

Si noti come il valore di $n$ (primo punto), ovvero dell'indice del registro più alto 
presente nel programma $P$, sia direttamente il valore della codifica di $P$. Questo
perchè $n$ vuole essere un limite superiore dell'indice più alto presente in $P$ e non
un valore esatto.

\subsubsection*{Implementazione}
Verrà mostrata ora l'implementazione dell'interprete $I_W$ scritto in (macro-)WHILE di un
programma RAM $P$:
$$ \semanticaWHILE_{I_W}(\cantor{x,n})=\semanticaRAM_n(x) $$
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.3mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetArgSty{relax}
    \SetAlgoNoEnd
    \SetKwSty{texttt}
    \tcp{Inizialmente l'input si trova in $x_1$}
    $x_2 := \sx(x_1)$\;
    $x_3 := \dx(x_1)$\;
    $x_0 := \cantor{0,x_2,\dots,0}$\;
    $x_1 := 1$\;
    \While(\hfill\texttt{// se $x_1=0$ allora STOP}){$x_1\neq 0$}{
        \eIf(\hfill\texttt{// supero l'ultima istruzione}){($x_1>\text{length($x_3$))}$}{
            $x_1:=0$\tcp*{STOP}
        }{
            $x_4 := \Pro(x_1,x_3)$\tcp*{estraggo istruzione corrente}
            \If(\hfill\texttt{// }$R_k\leftarrow R_k+1$){$x_4\bmod{3}=0$}{
                $x_5 := x_4 / 3$\tcp*{$k$}
                $x_0 := \text{incr}(x_5,x_0)$\;
                $x_1 := x_1+1$\;
            }
            \If(\hfill\texttt{// }$R_k\leftarrow R_k\dotminus1$){$x_4\bmod{3}=1$}{
                $x_5 := (x_4-1) / 3$\tcp*{$k$}
                $x_0 := \text{decr}(x_5,x_0)$\;
                $x_1 := x_1+1$\;
            }
            \If(\hfill\texttt{// }$\goto{R_k}{m}$){$x_4\bmod{3}=2$}{
                $x_5 := \sx((x_4+1)/3)$\tcp*{$k$}
                $x_6 := \dx((x_4+1)/3)$\tcp*{$m$}
                \eIf(\hfill\texttt{// verifico }$R_k=0$){Pro$(x_5,x_0)=0$}{
                    $x_1:=x_6$\;
                }{
                    $x_1:=x_1+1$\;
                }
            }
        }
    }
    $x_0 = \sx(x_0)$\tcp*{metto in $x_0$ il risultato $\semanticaRAM_n(x)$}
\end{algorithm}
\end{tcolorbox}

\subsubsection*{Conclusioni}
L'esistenza di $I_W$ permette la costruzione immediata di un compilatore:
$$ Comp:\text{PROG\ $\to$ W-PROG} $$

\renewcommand{\arraystretch}{1.25}
\begin{center}
\begin{tabular}{r|l|} \cline{2-2}
 $Comp(P)=$ & $n\leftarrow cod(P);$\\
            & $x_1 := \cantor{x_1,n};$\\
            & $I_W;$ \\ \cline{2-2}
\end{tabular}
\end{center}\vspace{.5cm}

$Comp$ non fa altro che mettere in $x_1$ il dato $x$ (già presente nella variabile $x_1$) e 
il programma codificato in $n$ aggregati tramite $\cantor{x,n}$ e far partire l'interprete 
$I_W$ che restituirà in $x_0$ il risultato della computazione.

Si è quindi appena dimostrata l'esistenza di una traduzione da RAM a WHILE che implica che:
$$ \text{$F$(RAM) $\subseteq$ $F$(WHILE)} $$

\subsubsection{Teorema di Böhm-Jacopini}
I risultati delle sezioni \ref{sec:FwhileFram} e \ref{sec:FramFwhile} permettono di dire
che:
$$ \begin{matrix}
    F(\text{RAM})\subseteq F(\text{WHILE}) \\
    F(\text{RAM})\supseteq F(\text{WHILE}) \\
\end{matrix} \quad \Rightarrow \quad
 F(\text{RAM})=F(\text{WHILE}) $$

\begin{theorem}[Teorema di Böhm-Jacopini]
    Per ogni programma con il comando \texttt{GOTO} (RAM) ne esiste uno equivalente in
    linguaggio strutturato (WHILE)
\end{theorem}

Questo teorema, enunciato nel 1966 da due informatici italiani, rappresenta un risultato
cruciale dell'informatica: mostra infatti che:
\begin{enumerate}
    \item Il comando di \texttt{GOTO} ha solo nati negativi e non è necessario;
    \item La programmazione a basso livello può essere sostituita da quella ad alto
        livello.
\end{enumerate}

Concludendo, si è anche dimostrato che:
$$ F(\text{RAM})=F(\text{WHILE}) \sim \N \nsim \N^\N_\perp $$
\textbf{Esistono quindi funzioni non computabili da entrambi i sistemi}.

\subsubsection{Interprete universale}
Si prenda il compilatore $Comp:\text{W-PROG}\to\text{PROG}$ e lo si utilizzi con $I_W$:
$$ \semanticaWHILE_{I_W}(\cantor{x,n})=\semanticaRAM_n(x) $$
$$ U = Comp(I_W)\in\text{PROG} $$
$U$ è detto interprete universale ed un programma RAM in grado di simulare qualsiasi
altro programma RAM.
La sua semantica è:
$$ \semanticaRAM_U(\cantor{x,n})=\semanticaWHILE_{I_W}(\cantor{x,n})=\semanticaRAM_n(x) $$

\subsection{Calcolabilità}
Nelle sezioni precedenti si è visto come due sistemi di calcolo molto diversi tra loro 
abbiano la stessa potenza computazionale numerabile:
$$ F(\text{RAM}) = F(\text{WHILE}) \sim \N \nsim \N^\N_\perp$$
e che quindi esistono delle funzioni non calcolabili da questi sistemi. Torna però qui la
questione: \quotes{E se esistesse un altro sistema di calcolo più potente?}

Bisognerà affrontare il problema a prescindere dalla macchina usata, definendo la 
calcolabilità in termini più matematici e \quotes{lontani} dall'informatica.

\subsubsection{Una prima idea di calcolabilità}
Per introdurre la definizione \quotes{teorica} di calcolabilità si introducano due insiemi:
\begin{itemize}
    \item $\elem$: insieme di tre funzioni molto semplici e banalmente implementabili;
    \item $\Omega$: insieme di operazioni su funzioni banalmente implementabili;
\end{itemize}

L'idea è che applicando un operazione facilmente calcolabile di $\Omega$ ad una funzione
facilmente calcolabile di $\elem$ ottengo un'altra funzione facilmente calcolabile:
$$ \elem^\Omega = \ricPar $$
$\ricPar$ è la classe delle funzioni ricorsive parziali e vuole essere una prima 
idea di classe di funzioni calcolabili. \textbf{Bisognerà ora capire quali funzioni compongono 
$\elem$ e quali operatori compongono $\Omega$}.

$\elem$ è composto da tre funzioni:

\begin{tabular}{l r l r l}
    $\elem =$ & $\{ \ \text{successore:}$ & $s(x)=x+1\ ,$&$x\in\N$ &\\
              & $\text{zero:}$ & $O^n(x_1,\dots,x_n)=0\ ,$&$x_i\in\N$ &\\
              & $\text{proiettori:}$ & $\text{pro}^n_k(x_1,\dots,x_n)=x_k\ ,$&$x_i\in\N$&
                \hspace{-.3cm}$\}$ \\
\end{tabular}

Le funzioni appena mostrare di $\elem$ devono essere incluse in un'idea di calcolabile:
sono proprio banali e semplici. Tuttavia ci saranno anche altre funzioni sicuramente calcolabili;
basti pensare che $f(x)=x+2$ non è presente in $\elem$ ma è certamente calcolabile.

Si deve quindi ampliare $\elem$ mantenendo sempre un'idea intuitiva di calcolabile: si
introdurrano gli operatori di composizione di funzioni e di ricorsione primitiva.

\subsubsection*{Operatore di composizione di funzioni}
Siano:
$$\begin{aligned}
    h:&\ \N^k\to\N \\
    g_1,\dots,g_k:&\ \N^n\to\N \\
    \sottolinea{x}\in&\ \N^n
\end{aligned}$$
Si definisce la composizione di funzioni come:
$$\comp(h,g_1,\dots,g_k):\ \N^n\to\N$$
$$\comp(h,g_1,\dots,g_k)(\sottolinea{x}) = h(g_1(\sottolinea{x}),\dots,g_k(\sottolinea{x}))$$

\begin{center}
    \input{figures/comp_function.tex}
\end{center}

Si ampli $\elem$ chiudendolo rispetto a $\comp$:
$$ \elem^\comp $$
$\elem$ viene ampliato; si può notare infatti che:
\begin{itemize}
    \item $f(x)=x+2 \notin \elem$
    \item $f(x)=x+2 \in \elem^\comp$ infatti $f(x)=\comp(s,s)(x)=s(s(x))=s(x+1)=x+2$
\end{itemize}
Tuttavia questo ampliamento non basta: $\elem^\comp$ infatti non contiene funzioni banali come
$\text{somma}(x,y)=x+y\notin\elem^\comp$.

\subsubsection*{Operatore di ricorsione primitiva}
Quest'operatore permette di definire funzioni ricorsive come:
$$ fatt(n) = \begin{cases}
    1 & n=0\\
    n*fatt(n-1) & n>0
\end{cases} $$

Siano:
\begin{center}
    \begin{tabular}{c l}
        $g:\ \N^n\to\N$ & funzione da applicare alla base ricorsiva\\
        $h:\ \N^{n+2}\to\N$ & funzione da applicare nel passo ricorsivo\\
        $g(\sottolinea{x})\ ,\ h(z,y,\sottolinea{x})$ con $\sottolinea{x}\in\N^n$\\
    \end{tabular}
\end{center}

Si definisce l'operatore di ricorsione primitiva:
$$ \RP(h,g) = f(\sottolinea{x},y) = \begin{cases}
    g(\sottolinea{x}) & y=0\\
    h(f(\sottolinea{x},y-1),y-1,\sottolinea{x}) & y>0
\end{cases}$$

Si noti che nel passo ricorsivo $h(f(\sottolinea{x},y-1),y-1,\sottolinea{x})$ non è detto
debbano essere gli ultimi due argomenti della funzione $h$.

\subsubsection{Funzioni ricorsive primitive}
Si ampli $\elem^\comp$ chiudendolo rispetto a $\RP$:
$$ \elem^{\comp,\RP} = \ricPrim $$
$\elem^{\comp,\RP}$ è formato dalle funzioni ricorsive primitive.

Alcuni esempi di funzioni ricorsive primitive sono:
$$\begin{aligned}
    \text{somma}(x,y) &= \RP({\color{blue}s},\text{pro}^1_1)\\
    &= \begin{cases}
        \text{pro}_1^1(x) & y=0\\
        {\color{blue}s}(\text{somma}(x,y-1),{\color{red}y-1},{\color{red}x}) & y>0
    \end{cases}\\
    &= \begin{cases}
        x & y=0\\
        {\color{blue}s}(\text{somma}(x,y-1)) & y>0
    \end{cases}\\[1em]
    \text{prodotto}(x,y) &= \RP({\color{blue}\text{somma}},O^1)\\
    &= \begin{cases}
        O^1(x) & y=0\\
        {\color{blue}\text{somma}}(\text{prodotto}(x,y-1),{\color{red}y-1},x) & y>0
    \end{cases}\\
    &= \begin{cases}
        0 & y=0\\
        {\color{blue}\text{somma}}(\text{prodotto}(x,y-1),x) & y>0
    \end{cases}\\[1em]
    \text{predecessore}(x) &= P(x) = \begin{cases}
        0 & x=0 \\ x-1 & x>0
    \end{cases}\\
    \dotminus(x,y)=x\dotminus y &= \RP({\color{blue}P},\text{pro}_1^1)\\
    &= \begin{cases}
        \text{pro}^1_1(x) & y=0\\
        {\color{blue}P}(\dotminus(x,y-1),{\color{red}y-1},{\color{red}x}) & y>0
    \end{cases}\\
    &= \begin{cases}
        x & y=0\\
        {\color{blue}P}(\dotminus(x,y-1)) & y>0
    \end{cases}
\end{aligned}$$

Si noti, come anticipato, che alcuni argomenti del passo ricorsivo {\color{red} possono non
essere usati} dalla funzione {\color{blue}$h$}

\subsubsection*{RICPRIM vs F(WHILE)}

RICPRIM contiene molte funzioni; si mostrerà ora che tutte le funzioni ricorsive primitive
possono essere calcolate da una macchina WHILE, ovvero:
$$ \ricPrim \subseteq F(\text{WHILE}) $$

La dimostrazione è fatta tramite induzione strutturale a partire dalla definizione di
$\ricPrim=\elem^{\comp,\RP}$:
\begin{enumerate}
    \item (BASE) Le funzioni in $\elem$ sono in $\ricPrim$
    \item (PASSO) $h,g_1,\dots,g_k\in\ricPrim \ \Rightarrow \ \comp(h,g_1,\dots,g_k)\in\ricPrim$
    \item (PASSO) $g,h\in\ricPrim \ \Rightarrow \ \RP(h,g)\in\ricPrim$
    \item Nient'altro è in $\ricPrim$
\end{enumerate}\label{sec:ricprim_while}
\vspace{1em}

Per dimostrare che $\ricPrim \subseteq F(\text{WHILE})$:
\begin{enumerate}
    \item Dimostro che $\elem\subseteq F(\text{WHILE})$, ovvero mostro per ogni funzione 
    $f\in\elem$ un programma $W\in W\text{-PROG}$ tale che $\semanticaWHILE_W=f$:
    \begin{itemize}
        \item $s(x)=x+1$:
        \begin{minipage}{.27\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := x_1+1$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
        \item $O^n(x_1,\dots,x_n)=0$:
        \begin{minipage}{.23\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := 0$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
        \item $\text{pro}^n_k(x_1,\dots,x_n)=x_k$:
        \begin{minipage}{.32\textwidth}
            \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
                \begin{algorithm}[H]
                    \SetKwSty{texttt}
                    \SetKwProg{begin}{begin}{}{end}
                    \begin{}{$x_0 := \Pro(k,x_1)$\;}
                \end{algorithm}
            \end{tcolorbox}
        \end{minipage}
    \end{itemize}
    \item Assumo che $h,g_1,\dots,g_k\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G_1,\dots,G_k\in W\text{-PROG}$ tali che:
        $$ \semanticaWHILE_H=h \ ,\ \semanticaWHILE_{G_1}=g_1\ ,\ \dots \ ,\
        \semanticaWHILE_{G_k}=g_k $$
        e dimostro che $\comp(h,g_1,\dots,g_k)\in F(\text{WHILE})$ ovvero mostro un programma
        WHILE che calcola:
        $$\comp(h,g_1,\dots,g_k)=h(g_1(\sottolinea{x}),\dots,g_k(\sottolinea{x}))$$
        \begin{center}
        \begin{minipage}{.85\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
        \begin{algorithm}[H]
            \setstretch{1.2}
            \SetKwSty{texttt}
            \SetKwProg{begin}{begin}{}{end}
            \begin{\hfill{\texttt{// }$x_1\leftarrow\sottolinea{x}=\cantor{a_1,\dots,a_n}$}}{
                $x_0 := G_1(x_1)$\;
                $x_0 := [x_0,G_2(x_1)]$\tcp*{Accoda $G_2(\sottolinea{x})$ all'array $x_0$}
                $\ \vdots$\\
                $x_0 := [x_0,G_k(x_1)]$\tcp*{$x_0:=[G_1(\sottolinea{x}),\dots,G_k(\sottolinea{x})]$}
                $x_0 := H(x_0)$\tcp*{$x_0:=H(G_1(\sottolinea{x}),\dots,G_k(\sottolinea{x}))$}
            }
        \end{algorithm}
        \end{tcolorbox}
        \end{minipage}
        \end{center}
    \begin{minipage}{.9\textwidth}
        \begin{algorithm}[H]
            \SetKwProg{begin}{begin}{}{end}

        \end{algorithm}
    \end{minipage}
    \item Assumo che $g,h\in F(\text{WHILE})$ ovvero che esistono dei programmi
    $H,G\in W\text{-PROG}$ tali che:
    $$ \semanticaWHILE_H=h \ ,\ \semanticaWHILE_{G}=g $$ 
    e dimostro che 
    $\RP(h,g)\in F(\text{WHILE})$ ovvero mostro un programma WHILE che calcola:
    $$ \RP(h,g) = f(\sottolinea{x},y) = \begin{cases}
    g(\sottolinea{x}) & y=0\\
    h(f(\sottolinea{x},y-1),y-1,\sottolinea{x}) & y>0
    \end{cases}$$
    \begin{center}
    \begin{minipage}{.85\textwidth}
    \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
    \begin{algorithm}[H]
        \setstretch{1.2}
        \SetKwSty{texttt}
        \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
        \tcp{Parto dalla base e salgo}
        \tcp{$x_1\leftarrow\cantor{\sottolinea{x},y}$}
        \begin{}{
            $t := G(\sottolinea{x})$\;
            $k := 1$\tcp*{$k$ mi dice a che punto sono}
            {\SetAlgoNoEnd
            \While(\hfill\texttt{// finchè $k$ non raggiunge $y$}){$k\leq y$}{
                \begin{}{
                    $t := H(t,k-1,\sottolinea{x})$\;
                    $k:=k+1$\;
                }
                \texttt{end}\;
            }}
        }
    \end{algorithm}
    \end{tcolorbox}
    \end{minipage}
    \end{center}\vspace{1em}
\end{enumerate}

Dunque per induzione strutturale si è dimostrato che:
$$ \ricPrim \subseteq F(\text{WHILE}) $$

Tuttavia resta la domanda sull'inclusione appena dimostrata: è propria?

Per rispondere basta notare che \textbf{$\ricPrim$ contiene solo funzioni totali}. La 
dimostrazione è semplice e si basa sulla definizione induttiva di $\ricPrim$:
\begin{itemize}
    \item (BASE) Le funzioni di $\elem$ sono totali;
    \item (PASSO) La composizione di funzioni totali è una funzione totale;
    \item (PASSO) La ricorsione primitiva di funzioni totali è una funzione totale: si ha sempre
        un caso base e per definzione si parte da $y$ e si decrementa di 1 fino ad arrivare a 0.
\end{itemize}

\textbf{$F(\text{WHILE})$ invece contiene anche funzioni parziali grazie ai suoi loop che possono
non terminare.}

Si ha quindi che:
$$ \bm{\ricPrim \subset F(\text{WHILE})} $$

\textbf{$\ricPrim$ quindi non basta a rappresentare il concetto di calcolabilità: bisogna 
ampliarlo introducendo una nuova operazione.}

\subsubsection*{Sistema di calcolo FOR}
Partendo dal linguaggio WHILE Si può introdurre un nuovo linguaggio, identico a quello WHILE,
ma che cambia l'istruzione di ciclo: viene usata l'istruzione, ben conosciuta, di
ciclo \texttt{for}:

\begin{center}
\begin{minipage}{.43\textwidth}
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetKwSty{texttt}
    \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
    \begin{}{
        $t := G(\sottolinea{x})$\;
        $k := 1$\;
        {\SetAlgoNoEnd
        \While{$k\leq y$}{
            \begin{}{
                $t := H(t,k-1,\sottolinea{x})$\;
                $k:=k+1$\;
            }
            \texttt{end}\;
        }}
    }
\end{algorithm}
\end{tcolorbox}
\end{minipage}
\begin{minipage}{.1\textwidth}
    \hspace{1.5em}$\to$
\end{minipage}
\begin{minipage}{.43\textwidth}
\begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
\begin{algorithm}[H]
    \setstretch{1.2}
    \SetArgSty{relax}
    \SetKwSty{texttt}
    \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
    \begin{}{
        $t := G(\sottolinea{x})$\;
        {\SetAlgoNoEnd
        \For{$k:=1$\texttt{ to }$y$}{
            $t := H(t,k-1,\sottolinea{x})$\;
        }}
    }
\end{algorithm}
\end{tcolorbox}
\end{minipage}
\end{center}

dove la variabile usata dal \texttt{for} non può essere toccata. Il linguaggio che ne deriva
viene chiamato linguaggio FOR e si può dire che:
$$ \ricPrim = F(\text{FOR}) \subset F(\text{WHILE}) $$

\subsubsection{Funzione di Ackermann}
Come già visto, $F(\text{WHILE})$ contiene delle funzioni parziali che $\ricPrim$ non ha.
Queste funzioni parziali derivano dalla possibiliità del linguaggio WHILE di ottenere dei
loop che non terminano. Sembra quindi che se si togliesse la possibilità di eseguire un loop
infinito dal linguaggio WHILE otterremmo $\ricPrim$.

Si prenda il linguaggio WHILE privato della possibilità di eseguire loop infiniti:
$$ \widetilde{F}(\text{WHILE}) = 
    \{\semanticaWHILE_W:W\in W\text{-PROG}\ \wedge\ \semanticaWHILE_W\text{ è totale}\} $$
Si ha che:
$$ \ricPrim\subseteq\widetilde{F}(\text{WHILE}) $$

È un'inclusione propria? \textbf{La risposta è sì.}

Per dimostrarlo si deve mostrare una funzione calcolabile in WHILE che non è ricorsiva primitiva.
Questa funzione è la funzione di Ackermann (1928):
$$ \mathscr{A}(m,n) = \begin{cases}
    n+1 & m=0\\
    \mathscr{A}(m-1,1) & m>0,n=0\\
    \mathscr{A}(m-1,\mathscr{A}(m,n-1)) & m,n>0
\end{cases} $$
Non si entrerà nel dettaglio ma basti sapere che $\mathscr{A}$ cresce troppo in fretta per poter
essere ricorsiva primitiva.

\textbf{Questo mostra che il sistema WHILE è più potente delle funzioni in $\ricPrim$ anche
escludendo gli \quotes{inutili} cicli infiniti}.

\subsubsection{RICPRIM non basta}
La ricerca delle funzioni calcolabili ha portato fin'ora all'insieme delle funzioni ricorsive
primitive $\ricPrim$ che, però, non si è dimostrato all'altezza mostrando \quotes{alcune lacune}
(Ackermann). Si dovrà quindi, ancora una volta, procedere con un ampliamento di $\ricPrim$.

\begin{center}
    \input{figures/calcolabilita1.tex}
\end{center}
\vspace{1em}

\subsubsection*{Operatore di minimalizzazione di funzioni}
Sia:
$$ f:\N^{n+1}\to\N $$
$$ f(\sottolinea{x},y)\text{ con }\sottolinea{x}\in\N^n $$
si definisce operatore di minimalizzazione di una funzione:
$$ \begin{aligned}
    \MIN(f)(\sottolinea{x}) = g(\sottolinea{x}) &=
    \begin{cases}
    y & f(\sottolinea{x},y)=0\ \wedge \ (\forall y'<y:f(\sottolinea{x},y')\text{\textdownarrow}\ 
    \wedge \ f(\sottolinea{x},y')\neq0)\\
    \perp & \text{altrimenti}
    \end{cases}\\
    &= \mu y(f(\sottolinea{x},y)=0)
\end{aligned}$$

A parole, $\MIN$ restituisce una funzione $g$ la quale restituisce il valore di $y$ più piccolo
che, fissata $\sottolinea{x}$, azzera $f(\sottolinea{x},y)$ o $\perp$ se non esiste un valore
che azzera $f(\sottolinea{x},y)$.

Alcuni esempi dell'applicazione di $\MIN$ sono:
\begin{center}
    \begin{tabular}{c|c}
        $\bm{f(x,y)}$ & $\bm{\textbf{\MIN}(f)(x)=g(x)}$\\ \hline
        $x+y+1$ & $\perp$\\
        $x\dotminus y$ & $x$\\
        $y\dotminus x$ & $0$\\
        $x\dotminus y^2$ & $\left\lceil\sqrt{x}\right\rceil$\\
        $\left\lfloor\frac{x}{y}\right\rfloor$ & $\perp$\\
    \end{tabular}
\end{center}

\subsubsection{Funzioni ricorsive parziali}
Come già fatto precedentemente si ampli $\ricPrim$ chiudendo $\ricPrim=\elem^{\comp,\RP}$
rispetto alla nuovo operazione introdotta $\MIN$:
$$ \elem^{\comp,\RP,\MIN} = \ricPar $$
Le funzioni di $\ricPar$ sono dette funzioni ricorsive parziali.

Sicuramente $\ricPar$ è più grande di $\ricPrim$ vista la presenza di funzioni parziali. Ma che
rapporto ha $\ricPar$ con $F(\text{WHILE})$?

\begin{theorem}\label{th:ricParWhile}
    $\ricPar \subseteq F(\text{WHILE})$
\end{theorem}
\begin{proof}
    Si usi l'induzione strutturale su $\ricPar=\elem^{\comp,\RP,\MIN}$, che può essere definito
    induttivamente:
    \begin{enumerate}
        \item Le funzioni di $\elem$ sono in $\ricPar$
        \item $h,g_1,\dots,g_k\in\ricPar\ \Rightarrow\ \comp(h,g_1,\dots,g_k)\in\ricPar$
        \item $h,g\in\ricPar\ \Rightarrow\ \RP(h,g)\in\ricPar$
        \item $f\in\ricPar\ \Rightarrow\ \MIN(f)\in\ricPar$
        \item Null'altro è in $\ricPar$
    \end{enumerate}
    Per dimostrare che $\ricPar \subseteq F(\text{WHILE})$:
    \begin{enumerate}
    \item Dimostro che $\elem\subseteq F(\text{WHILE})$, ovvero mostro per ogni funzione 
    $f\in\elem$ un programma $W\in W\text{-PROG}$ tale che $\semanticaWHILE_W=f$: già visto
    nella sezione \ref{sec:ricprim_while}
    \item Assumo che $h,g_1,\dots,g_k\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G_1,\dots,G_k\in W\text{-PROG}$ tali che:
        $$ \semanticaWHILE_H=h \ ,\ \semanticaWHILE_{G_1}=g_1\ ,\ \dots \ ,\
        \semanticaWHILE_{G_k}=g_k $$
        e dimostro che $\comp(h,g_1,\dots,g_k)\in F(\text{WHILE})$: già visto nella sezione
        \ref{sec:ricprim_while}.
    \begin{minipage}{.9\textwidth}
        \begin{algorithm}[H]
            \SetKwProg{begin}{begin}{}{end}

        \end{algorithm}
    \end{minipage}
    \item Assumo che $g,h\in F(\text{WHILE})$ ovvero che esistono dei programmi
        $H,G\in W\text{-PROG}$ tali che:
        $$ \semanticaWHILE_H=h \ ,\ \semanticaWHILE_{G}=g $$ 
        e dimostro che 
        $\RP(h,g)\in F(\text{WHILE})$: già visto nella sezione \ref{sec:ricprim_while}.
    \item Assumo che $f\in F(\text{WHILE})$ ovvero che esiste un programma $\mathcal{F}\in
        F(\text{WHILE})$ tale che $\semanticaWHILE_\mathcal{F}=f$
        e dimostro che $\MIN(f)\in F(\text{WHILE})$ ovvero mostro un programma WHILE
        che calcola:
        $$ \begin{aligned}
            \MIN(f)(\sottolinea{x}) = g(\sottolinea{x}) &=
            \begin{cases}
                \mu y(f(\sottolinea{x},y)=0)\\
                \perp & \text{se non esiste tale $y$}
            \end{cases}
        \end{aligned}$$
        \vspace{.7em}

        \begin{minipage}{.52\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
        \begin{algorithm}[H]
            \setstretch{1.2}
            \SetKwSty{texttt}
            \SetKwProg{begin}{\texttt{begin}}{}{\texttt{end}}
            \tcp{$x_1\leftarrow\sottolinea{x}$}
            \begin{}{
                $y:=0$\tcp*{parto da 0}
                {\SetAlgoNoEnd
                \While{$F(\sottolinea{x},y)\neq 0$}{
                    $y:=y+1$\tcp*{salgo di 1}
                }}
            }
        \end{algorithm}
        \end{tcolorbox}
        \end{minipage}\hfill
        \begin{minipage}{.37\textwidth}
            L'idea del programma è partire dal valore più basso che $y$ può assumere
            in $\N$, ovvero 0, per poi salire di un'unita fino a trovare il primo valore 
            che azzera $f(\sottolinea{x},y)$; se il valore non esiste o $F(\sottolinea{x},y)$
            va in loop prima di trovarlo si avrà un loop che produce $\perp$ in output.
        \end{minipage}
    \end{enumerate} 
\end{proof}
Il precedente teorema permette di dire che qualsiasi funzione ricorsiva parziale può essere
calcolata da un programma WHILE. Si vedrà ora che per qualsiasi programma WHILE esiste una
funzione ricorsiva parziale che è uguale alla semantica del programma 
($F(\text{WHILE}) \subseteq \ricPar$).

\begin{theorem}
    $F(\text{WHILE}) \subseteq \ricPar$
\end{theorem}
\begin{proof}
    Se $F(\text{WHILE}) \subseteq \ricPar$ allora:
    $$ \semanticaWHILE_W\in F(\text{WHILE})\ \Rightarrow\ \semanticaWHILE_W
    \in\ricPar = \elem^{\comp,\RP,\MIN}$$
    Si dovrà quindi dimostrare che per un qualsiasi programma $W$, la sua semantica
    $\semanticaWHILE_W$ apparterrà a $\ricPar$ e potrà essere espressa come
    composizione, ricorsione primitiva e minimalizzazione a partire da funzioni di
    $\elem$.

    $$ \semanticaWHILE_W(x) = \Pro_0^{21}(\opsemWHILE{W}{W\text{-in}(x)}) $$
    \begin{itemize}
        \item La funzione \opsemWHILE{C}{\sottolinea{x}} restituisce un array di 21
            elementi che rappresenta lo stato prossimo della macchina WHILE applicando
            il comando $C$ allo stato attuale $\sottolinea{x}$;
        \item La funzione $W\text{-in}(n)$ restituisce lo stato iniziale della
            macchina WHILE su input $n$;
        \item $\Pro_0^{21}$ preleva l'output dal registro $x_0$.
    \end{itemize}
    $\semanticaWHILE_W$ è la composizione di $\Pro_0^{21}\in\elem$ con la funzione
    stato prossimo $\opsemWHILE{W}{W\text{-in}(x)}$. Si ha quindi che:

    \begin{minipage}{.5\textwidth}
    \begin{enumerate}
        \item $\Pro_0^{21}\in\elem \ \Rightarrow \ \Pro_0^{21}\in\ricPar$
        \item $\ricPar$ è chiuso rispetto alla composizione
    \end{enumerate}
    \end{minipage}
    \begin{minipage}{.4\textwidth}
        $\Rightarrow \quad \opsemWHILE{C}{\sottolinea{x}}\in\ricPar \ \Rightarrow \ 
        \semanticaWHILE_W\in\ricPar$
    \end{minipage}

    Se quindi si dimostra che $\opsemWHILE{C}{\sottolinea{x}}\in\ricPar$ allora anche
    la sua semantica $\semanticaWHILE_W$ sarà una funzione ricorsiva parziale.

    La funzione $\opsemWHILE{}{}:\N^{21}\to\N^{21}$ ha come codominio $\N^{21}$ mentre
    $\ricPar$ contiene funzioni che lavorano in $\N$: per risolvere questo problema
    si definisca una nuova funzione $f_C$ in cui viene applicato Cantor sull'array 
    degli stati:
    $$ \opsemWHILE{C}{\sottolinea{x}} = \sottolinea{y} \quad \text{con }
     \ \ \sottolinea{x},\sottolinea{y}\in\N^{21}$$
    $$ f_C(x)=y \quad \text{con }
     \ \ x=[\sottolinea{x}]\ ,\ y=[\sottolinea{y}]$$
    
    Si noti che per passare da $\opsemWHILE{C}{\sottolinea{x}}$ a $f_C(x)$ 
    si usano operazioni ricorsive parziali:
    $$\begin{aligned}
        f_C(x)&=y\\
        {\color{red}\Pro\in\ricPar}\quad &
        \mathlarger{{\color{red}\downarrow}{\color{blue}\uparrow}}
        \quad\color{blue}[\ ]\in\ricPar\\
        \opsemWHILE{C}{\Pro(0,x),\dots,\Pro(20,x)}&=(\Pro(0,y),\dots,\Pro(20,y))
    \end{aligned}$$
    Quindi si ha che $f_C$ si comporta come $\opsemWHILE{C}{\sottolinea{x}}$ sullo 
    stato prossimo. Basterà ora dimostrare che $f_C$ effettivamente è una funzione
    ricorsiva parziale:
    $$ f_C\in\ricPar \ \ \Leftrightarrow \ \ \opsemWHILE{C}{\sottolinea{x}}\in\ricPar$$

    Vista la definizione induttiva di $\opsemWHILE{}{}$ si usi l'induzione
    strutturale:
    \begin{itemize}
        \item BASE:
            \begin{itemize}
                \renewcommand{\labelitemii}{\raisebox{5.2\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{x_k:=0} \\[.6em]
                    &\hspace{2em}f_C(x) = {\color{red}[}
                    {\color{red}\Pro}(0,x),\dots,{\color{red}0},\dots,{\color{red}\Pro}
                    (20,x){\color{red}]}\\
                    &\hspace{10.05em}\overset{\uparrow}{\text{posizione $k$}}\\
                    & \text{Viene usata una composizione di {\color{red}funzioni 
                        $\in\ricPar$}}
                        \ \Rightarrow \ f_{x_k:=0}\in\ricPar
                \end{aligned}$
                \renewcommand{\labelitemii}{\raisebox{5.2\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{x_k:=x_j+/\dotminus 1}\\[.6em]
                    &\hspace{2em}f_C(x) = {\color{red}[}
                    {\color{red}\Pro}(0,x),\dots,
                    {\color{red}\Pro}(j,x){\color{red}+/\dotminus 1}
                    ,\dots,{\color{red}\Pro}
                    (20,x){\color{red}]}\\
                    &\hspace{10.05em}\overset{\uparrow}{\text{posizione $k$}}\\
                    & \text{Viene usata una composizione di {\color{red}funzioni 
                        $\in\ricPar$}}
                        \ \Rightarrow \ f_{x_k:=x_j\pm1}\in\ricPar
                \end{aligned}$
            \end{itemize}
        \item PASSO:
            \begin{itemize}
                \renewcommand{\labelitemii}{\raisebox{2.1\height}{$-$}}
                \item $\begin{aligned}
                    &C\equiv \boxed{
                        \textbegin C_ 1; \ C_2; \ \dots; \ C_m; \textend
                    }\\[.6em]
                    &\hspace{2em}f_C(x) = f_{C_m}(\dots f_{C_1}(x)\dots)\\
                \end{aligned}$
                \vspace{.7em}

                Viene usata una composizione di $f_{C_i}\in\ricPar$
                per ipotesi induttiva $\ \Rightarrow \ f_{C}\in\ricPar $

                \renewcommand{\labelitemii}{\raisebox{2.1\height}{$-$}}
                \item $\begin{aligned}
                    &C'\equiv \boxed{\while{x_k}{C}}\\[.6em]
                    &\hspace{2em}f_{C'}(x) = f_C^{e(x)}(x)
                    \ \ \text{ con } \ e(x)=\mu y(\Pro(k,f_c^y(x))=0)\\
                \end{aligned}$

                Sorge qui un problema: $e(x)$ non è costante; non basta quindi 
                la composizione in quanto può essere applicata solo su un numero 
                costante di funzioni.

                Si dovrà allora definire una funzione $T\in\ricPar$:
                $$T(x,y)=f_C^y(x)$$
                È facile farlo usando l'operatore di ricorsione primitiva $\RP$:
                $$ T(x,y) = \begin{cases}
                    x&y=0\\
                    f_C(T(x,y-1))&y>0
                \end{cases} $$
                Siccome:

                \begin{minipage}{.38\textwidth}
                \begin{enumerate}
                    \item $f_C\in\ricPar$ per ipotesi induttiva
                    \item $\RP\in\ricPar$
                \end{enumerate}
                \end{minipage}
                \begin{minipage}{.4\textwidth}
                    $\Rightarrow \ T(x,y)\in\ricPar$
                \end{minipage}
                
                $$ \begin{aligned}
                    e(x)&=\mu y(\Pro(k,f_c^y(x))=0)\\
                    &=\mu y(\Pro(k,T(x,y))=0)
                \end{aligned} $$
                $e(x)$ è una minimalizzazione di $T(x,y)\in\ricPar$, quindi 
                $e(x)\in\ricPar$

                Infine:
                $$ f_{C'}(x) = f_C^{e(x)}(x) = {\color{red}T}(x,{\color{red}e}(x)) $$
                $f_{C'}$ è formato da una composizione di funzioni $\in\ricPar$
                $\ \Rightarrow \ f_{C'}\in\ricPar$.
            \end{itemize}
    \end{itemize}
    Per induzione strutturale si conclude che $F(\text{WHILE}) \subseteq \ricPar$.
\end{proof}

Il precedente teorema unito al teorema \ref{th:ricParWhile} permettono di affermare che:
$$ F(\text{WHILE}) = \ricPar $$

\subsubsection{Funzioni ricorsive totali}
Il seguente schema mostra il quadro generale dell'idea intuitiva di calcolabilità:
\vspace{1em}
\begin{center}
    \input{figures/calcolabilita2.tex}
\end{center}

L'insieme $\ricPar$ delle funzioni ricorsive parziali contiene tutte le funzioni
calcolabili, incluse quelle parziali. Questo vuol dire che in $\ricPar$ ci sono anche
programmi che non garantiscono una risposta in quanto potrebbero andare il loop.

Per delinare tutte le funzioni totali calcolabili, ovvero che possono essere calcolate
da programmi che garantiscono una risposta, viene usato l'insieme delle funzioni
ricorsive totali $\ricTot$:
$$\ricTot = \{\text{funzioni ricorsive totali}\} $$
\vspace{.1em}
\begin{center}
    \input{figures/calcolabilita3.tex}
\end{center}
\vspace{.5em}

\subsubsection{Tesi di Church-Turing}
Numerosi studiosi, a partire dagli anni 30, hanno provato a formalizzare il concetto di
calcolabilità cercando quindi di definire quali siano le funzioni che possono essere
calcolate da un qualsiasi programma in un qualsiasi sistema di calcolo.

Per farlo, sono stati introdotti innumerovoli e variegati sistemi di calcolo e, per
ognuno di questi, è stato studiato che tipo di funzioni sono in grado di calcolare:
\textbf{in tutti i casi si è arrivati alla stessa conclusione, ovvero che i sistemi
di calcolo visti sono in gado di calcolare funzioni ricorsive primite.}

Da qui deriva la tesi di Church-Turing:
\begin{center}
    \begin{minipage}{.9\textwidth}
        \begin{tcolorbox}[colback=white,sharp corners,boxrule=.2mm]
            Le classi delle funzioni intuitivamente calcolabili coincide con la classe 
            $\ricPar$ delle funzioni ricorsive parziali;
        \end{tcolorbox}
    \end{minipage}
\end{center}
Per intuitivamente calcolabile si intende calcolabile da un modello di calcolo
\quotes{ragionevole} come quelli mostrati nel corso degli ultimi cent'anni.

\textbf{È importante sottolineare che la tesi di Church-Turing è una congettura, 
un'opinione. Non c'è infatti nessuna evidenza che non possa esistere un sistema di 
calcolo in grado di calcolare funzioni $f\notin\ricPar$.}

